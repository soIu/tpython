
## Function: tp_true
## Check the truth value of an object
## Returns false if v is a numeric object with a value of exactly 0, v is of
## type None or v is a string list or dictionary with a length of 0. Else true
## is returned.
def tp_true(TP,tp_obj v) ->int:
	switch v.type.type_id:
		case TP_NUMBER: return v.number.val != 0;
		case TP_NONE: return 0;
		case TP_STRING: return tp_string_len(v) != 0;
		case TP_LIST: return v.list.val->len != 0;
		case TP_DICT: return v.dict.val->len != 0;
	return 1;


## Function: tp_has
## Checks if an object contains a key.
## Returns tp_True if self[k] exists, tp_False otherwise.
def tp_has(TP,tp_obj self, tp_obj k) ->tp_obj:
	int type = self.type.type_id
	if type == TP_DICT:
		if tpd_dict_hashfind(tp, self.dict.val, tp_hash(tp, k), k) != -1:
			return tp_True
		return tp_False
	elif type == TP_STRING && k.type.type_id == TP_STRING:
		return tp_number(tp_str_index(self,k)!=-1)
	elif type == TP_LIST:
		return tp_number(tpd_list_find(tp, self.list.val, k, tp_cmp)!=-1)
	##tp_raise(tp_None,tp_string_atom(tp, "(tp_has) TypeError: iterable argument required"));
	throw "TypeError in tp_ops.cpp:tp_has iterable argument required"


## Function: tp_del
## Remove a dictionary entry.
## Removes the key k from self. Also works on classes and objects.
## Note that unlike with Python, you cannot use this to remove list items.
def tp_del(TP, tp_obj self, tp_obj k):
	int type = self.type.type_id
	if type == TP_DICT:
		tp_dict_del(tp, self, k)
		return
	##tp_raise(,tp_string_atom(tp, "(tp_del) TypeError: object does not support item deletion"));
	throw "TypeError in tp_ops.cpp:tp_del object does not support item deletion"


## Function: tp_iter
## Iterate through a list or dict.
## If self is a list/string/dictionary, this will iterate over the
## elements/characters/keys respectively, if k is an increasing index
## starting with 0 up to the length of the object-1.
## In the case of a list of string, the returned items will correspond to the
## item at index k. For a dictionary, no guarantees are made about the order.
## You also cannot call the function with a specific k to get a specific
## item -- it is only meant for iterating through all items, calling this
## function len(self) times. Use <tp_get> to retrieve a specific item, and
## <tp_len> to get the length.
##
## Parameters:
## self - The object over which to iterate.
## k - You must pass 0 on the first call, then increase it by 1 after each call,
##     and do not call the function with k >= len(self).
##
## Returns:
## The first (k = 0) or next (k = 1 .. len(self)-1) item in the iteration.

def tp_iter(TP,tp_obj self, tp_obj k) ->tp_obj:
	int type = self.type.type_id
	if type == TP_LIST || type == TP_STRING:
		return tp_get(tp,self,k)
	if type == TP_DICT && k.type.type_id == TP_NUMBER:
		return self.dict.val->items[tpd_dict_next(tp,self.dict.val)].key
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_iter) TypeError: iteration over non-sequence"));
	throw "TypeError in tp_ops.cpp:tp_iter iteration over a non-sequence";

## Function: tp_get
## Attribute lookup.
## 
## This returns the result of using self[k] in actual code. It works for
## dictionaries (including classes and instantiated objects), lists and strings.
##
## As a special case, if self is a list, self[None] will return the first
## element in the list and subsequently remove it from the list.

static tp_obj _tp_get(TP, tp_obj self, tp_obj k, int mget);

## lookup using []; never bind functions
def tp_get(TP, tp_obj self, tp_obj k) ->tp_obj: 
	return _tp_get(tp, self, k, 0)

## lookup using .; always bind functions. FIXME: static and class binding
def tp_mget(TP, tp_obj self, tp_obj k) ->tp_obj:
	return _tp_get(tp, self, k, 1)

def tp_get_by_char(TP, tp_obj d, char c) ->tp_obj:
	//std::string s{c}
	//tp_obj key = tp_string_from_stdstring(tp, s)
	tp_obj key = tp_string_from_buffer(tp, (const char*)&c, 1)
	tp_obj item = tp_dict_get(tp, d, key)
	return item


def tp_set_by_char(TP, tp_obj self, char c, tp_obj value):
	//std::string s{c};
	//tp_obj key = tp_string_from_stdstring(tp, s);
	tp_obj key = tp_string_from_buffer(tp, (const char*)&c, 1)
	tp_dict_set(tp, self, key, value)


@static
def _tp_get(TP, tp_obj self, tp_obj k, int mget) -> tp_obj:
	int type = self.type.type_id
	tp_obj r
	if type == TP_VEC2:
		if k == "x":
			return tp_number(self.vec2.vec.x)
		elif k == "y":
			return tp_number(self.vec2.vec.y)
		elif k == "angle":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.vec2.vec.angle())
			return tp_function(tp, fn)
		elif k == "aspect":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.vec2.vec.aspect())
			return tp_function(tp, fn)
		elif k == "length":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.vec2.vec.length())
			return tp_function(tp, fn)
		elif k == "normalized":
			## note, do not need to create a new tp_vec2 because this is already a copy
			auto fn = def[=](tp_vm *t):
				auto v = self
				v.vec2.vec.normalize()
				return v
			return tp_function(tp, fn)
		else:
			throw "vector2 missing member"
	elif type == TP_VEC3:
		if k == "x":
			return tp_number(self.vec3.vec.x)
		elif k == "y":
			return tp_number(self.vec3.vec.y)
		elif k == "z":
			return tp_number(self.vec3.vec.z)
		elif k == "length":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.vec3.vec.length())
			return tp_function(tp, fn)
		elif k == "normalized":
			## note, do not need to create a new tp_vec2 because this is already a copy
			auto fn = def[=](tp_vm *t):
				auto v = self
				v.vec3.vec.normalize()
				return v
			return tp_function(tp, fn)
		else:
			throw "vector3 missing member"
	elif type == TP_QUAT:
		if k == "x":
			return tp_number(self.quat.q.x)
		elif k == "y":
			return tp_number(self.quat.q.y)
		elif k == "z":
			return tp_number(self.quat.q.z)
		elif k == "w":
			return tp_number(self.quat.q.w)
		elif k == "length":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.quat.q.length())
			return tp_function(tp, fn)
		elif k == "normalized":
			## note, do not need to create a new tp_vec2 because this is already a copy
			auto fn = def[=](tp_vm *t):
				auto v = self
				v.quat.q.normalize()
				return v
			return tp_function(tp, fn)
		else:
			throw "quat missing member"
	elif type == TP_COLOR:
		if k == "r":
			return tp_number(self.color.c.r)
		elif k == "g":
			return tp_number(self.color.c.g)
		elif k == "b":
			return tp_number(self.color.c.b)
		elif k == "a":
			return tp_number(self.color.c.a)
		elif k == "darkened":
			## note, do not need to create a new tp_vec2 because this is already a copy
			auto fn = def[=](TP):
				auto amount = TP_OBJ()
				auto v = self
				v.color.c = self.color.c.darkened(amount.number.val)
				return v
			return tp_function(tp, fn)
		else:
			throw "color missing member"
	elif type == TP_RECT:
		if k == "x":
			return tp_number(self.rect.r.position.x)
		elif k == "y":
			return tp_number(self.rect.r.position.y)
		elif k == "width":
			return tp_number(self.rect.r.size.x)
		elif k == "height":
			return tp_number(self.rect.r.size.y)
		elif k == "get_area":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.rect.r.get_area())
			return tp_function(tp, fn)
		else:
			throw "rect missing member"
	elif type >= TP_HAS_META:
		if type == TP_DICT:
			## '.' looks for methods of a raw dict.
			## [] looks for members
			if mget:
				if tp_vget(tp, self, k, &r, 1):
					return r
			else:
				return tp_dict_get(tp, self, k)
		elif type == TP_LIST:
			if k.type.type_id == TP_NUMBER:
				int l = tp_len(tp,self).number.val
				int n = k.number.val
				n = (n<0?l+n:n)
				return tpd_list_get(tp, self.list.val, n, "tp_get")
			elif k.type.type_id == TP_STRING:
				if tp_vget(tp, self, k, &r, 1):
					return r
			elif k.type.type_id == TP_NONE:
				return tpd_list_pop(tp, self.list.val, 0, "tp_get")
		elif type == TP_STRING:
			if k.type.type_id == TP_NUMBER:
				int l = tp_string_len(self)
				int n = k.number.val
				n = (n<0?l+n:n)
				if (n >= 0 && n < l) { return tp_string_t_from_const(tp, tp->chars[(unsigned char) tp_string_getptr(self)[n]], 1); }
			elif k.type.type_id == TP_STRING:
				if tp_vget(tp, self, k, &r, 1):
					return r
		elif type == TP_OBJECT:
			## not a raw dict, must be object or interface
			#ifdef DEBUG
			  print("	begin _tp_get: ")
			  print(tp_as_string(tp,k))
			#endif
			TP_META_BEGIN(self,"__getitem__")
			  return tp_call(tp, meta, tp_params_v(tp, 1, k))
			TP_META_END
			#ifdef DEBUG
			  print("	falling back to tp_vget")
			#endif
			if tp_vget(tp, self, k, &r, mget):
				#ifdef DEBUG
				  print("	_tp_get OK")
				#endif
				return r
			#ifdef DEBUG
			  print("	_tp_get failure")
			#endif
		elif type == TP_INTERFACE:
			if tp_vget(tp, self, k, &r, 0):
				return r
	## deal with list / string keys on any unknown types
	if k.type.type_id == TP_LIST:
		int a,b,l
		tp_obj tmp
		l = tp_len(tp,self).number.val
		tmp = tp_get(tp,k,tp_number(0))
		if tmp.type.type_id == TP_NUMBER:
			a = tmp.number.val
		elif tmp.type.type_id == TP_NONE:
			a = 0
		else:
			//tp_raise(tp_None,tp_string_atom(tp, "(tp_get) TypeError: indices must be numbers")); 
			throw "TypeError in tp_ops.cpp:_tp_get indices must be a number"
		tmp = tp_get(tp,k,tp_number(1))
		if tmp.type.type_id == TP_NUMBER:
			b = tmp.number.val
		elif tmp.type.type_id == TP_NONE:
			b = l
		else:
			//tp_raise(tp_None,tp_string_atom(tp, "(tp_get) TypeError: indices must be numbers")); 
			throw "TypeError in tp_ops.cpp:_tp_get indices must be a number"
		a = _tp_max(0,(a<0?l+a:a))
		b = _tp_min(l,(b<0?l+b:b))
		if type == TP_LIST:
			return tp_list_from_items(tp,b-a,&self.list.val->items[a])
		elif type == TP_STRING:
			return tp_string_view(tp,self,a,b)
	elif k.type.type_id == TP_STRING:
		## this is not correct, unknowntype.foo should not return unknowntype
		return tp_copy(tp, self)
	print("_tp_get: self =")
	print(tp_as_string(tp, self))
	print("_tp_get: key =")
	print(tp_as_string(tp, k))
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_get) TypeError: ?"));
	throw "TypeError in tp_ops.cpp:_tp_get unexpected type"

## function: tp_copy
def tp_copy(TP, tp_obj self) -> tp_obj:
	int type = self.type.type_id
	if type == TP_NUMBER:
		return self
	elif type == TP_INTEGER:
		return self
	elif type == TP_VEC2:
		return self
	elif type == TP_VEC3:
		return self
	elif type == TP_STRING:
		return tp_string_from_buffer(tp, tp_string_getptr(self), tp_string_len(self))
	elif type == TP_LIST:
		return tp_list_copy(tp, self)
	elif type == TP_DICT || type == TP_INTERFACE || type == TP_OBJECT:
		return tp_dict_copy(tp, self)
	//tp_raise(tp_None, tp_string_atom(tp, "(tp_copy) TypeError: object does not support copy"));
	throw "TypeError in tp_ops.cpp:tp_copy object does not support copy"



## Function: tp_iget
## Failsafe attribute lookup.
## This is like <tp_get>, except it will return false if the attribute lookup
## failed. Otherwise, it will return true, and the object will be returned
## over the reference parameter r.

def tp_iget(TP,tp_obj *r, tp_obj self, tp_obj k) ->int:
	if self.type.type_id == TP_DICT || self.type.type_id == TP_OBJECT || self.type.type_id == TP_INTERFACE:
		int n = tpd_dict_hashfind(tp, self.dict.val, tp_hash(tp, k), k)
		if n == -1:
			return 0
		*r = self.dict.val->items[n].val
		tp_grey(tp,*r)
		return 1
	if self.type.type_id == TP_LIST && !self.list.val->len:
		return 0
	*r = tp_get(tp,self,k)
	tp_grey(tp,*r)
	return 1;


## Function: tp_set
## Attribute modification.
## This is the counterpart of tp_get, it does the same as self[k] = v would do
## in actual tinypy code.

def tp_set(TP,tp_obj self, tp_obj k, tp_obj v) -> tp_obj:
	int type = self.type.type_id
	if type == TP_VEC2:
		if k == "x":
			self.vec2.vec.x = v.number.val
		elif k == "y":
			self.vec2.vec.y = v.number.val
		else:
			throw "vector2 type missing member"
		return self
	elif type == TP_VEC3:
		if k == "x":
			self.vec3.vec.x = v.number.val
		elif k == "y":
			self.vec3.vec.y = v.number.val
		elif k == "z":
			self.vec3.vec.z = v.number.val
		else:
			throw "vector3 type missing member"
		return self
	elif type == TP_QUAT:
		if k == "x":
			self.quat.q.x = v.number.val
		elif k == "y":
			self.quat.q.y = v.number.val
		elif k == "z":
			self.quat.q.z = v.number.val
		elif k == "w":
			self.quat.q.w = v.number.val
		else:
			throw "quat type missing member"
		return self
	elif type == TP_COLOR:
		if k == "r":
			self.color.c.r = v.number.val
		elif k == "g":
			self.color.c.g = v.number.val
		elif k == "b":
			self.color.c.b = v.number.val
		elif k == "a":
			self.color.c.a = v.number.val
		else:
			throw "color type missing member"
		return self
	elif type == TP_RECT:
		if k == "x":
			self.rect.r.position.x = v.number.val
		elif k == "y":
			self.rect.r.position.y = v.number.val
		elif k == "width":
			self.rect.r.size.x = v.number.val
		elif k == "height":
			self.rect.r.size.y = v.number.val
		else:
			throw "rect type missing member"
		return self
	elif type == TP_DICT:
		tp_dict_set(tp, self, k, v)
		return self
	elif type == TP_LIST:
		if k.type.type_id == TP_NUMBER:
			tpd_list_set(tp, self.list.val, k.number.val, v, "tp_set")
			return self
		elif k.type.type_id == TP_NONE:
			tpd_list_append(tp, self.list.val, v)
			return self
		elif k.type.type_id == TP_STRING:
			## WTF is this syntax? a['*'] = b will extend a by b ??
			## FIXME: remove this support. Use a + b
			if tp_cmp(tp, tp_string_atom(tp, "*"), k) == 0:
				tpd_list_extend(tp, self.list.val, v.list.val)
				return self
	elif type == TP_INTERFACE:
		tp_dict_set(tp, self, k, v)
		return self
	elif type == TP_OBJECT:
		TP_META_BEGIN(self,"__set__")
		  tp_call(tp,meta,tp_params_v(tp,2,k,v))
		  return self
		TP_META_END
		tp_dict_set(tp, self, k, v)
		return self
	//tp_raise(,tp_string_atom(tp, "(tp_set) TypeError: object does not support item assignment"));
	throw "TypeError in tp_ops.cpp:tp_set object does not support item assignment"


def tp_add(TP, tp_obj a, tp_obj b) -> tp_obj:
	if a.type.type_id == TP_NUMBER && a.type.type_id == b.type.type_id:
		return tp_number(a.number.val+b.number.val)
	elif a.type.type_id == TP_STRING && a.type.type_id == b.type.type_id:
		return tp_string_add(tp, a, b)
	elif a.type.type_id == TP_LIST && a.type.type_id == b.type.type_id:
		return tp_list_add(tp, a, b)
	elif a.type.type_id == TP_VEC2 && a.type.type_id == b.type.type_id:
		## a is already a copy
		a.vec2.vec = a.vec2.vec + b.vec2.vec
		return a
	elif a.type.type_id == TP_VEC3 && a.type.type_id == b.type.type_id:
		## a is already a copy
		a.vec3.vec = a.vec3.vec + b.vec3.vec
		return a
	elif a.type.type_id == TP_QUAT && a.type.type_id == b.type.type_id:
		## a is already a copy
		a.quat.q = a.quat.q + b.quat.q
		return a
	##tp_raise(tp_None,tp_string_atom(tp, "(tp_add) TypeError: ?"));
	print("operand A::type_id ")
	print(a.type.type_id)
	print("operand B::type_id ")
	print(b.type.type_id)
	throw "TypeError in tp_ops.cpp:tp_add invalid object type to use the add operator with"


def tp_mul(TP,tp_obj a, tp_obj b) -> tp_obj:
	if a.type.type_id == TP_NUMBER && a.type.type_id == b.type.type_id:
		return tp_number(a.number.val*b.number.val)
	if a.type.type_id == TP_NUMBER:
		tp_obj c = a; a = b; b = c
	if a.type.type_id == TP_STRING && b.type.type_id == TP_NUMBER:
		int n = b.number.val
		return tp_string_mul(tp, a, n)
	if a.type.type_id == TP_LIST && b.type.type_id == TP_NUMBER:
		int n = b.number.val
		return tp_list_mul(tp, a, n)
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_mul) TypeError: ?"));
	throw "TypeError in tp_ops.cpp:tp_mul invalid object type to use the multiply operator with"


## Function: tp_len
## Returns the length of an object.
## Returns the number of items in a list or dict, or the length of a string.
def tp_len(TP,tp_obj self) -> tp_obj:
	int type = self.type.type_id;
	if type == TP_STRING:
		return tp_number(tp_string_len(self))
	elif type == TP_DICT:
		return tp_number(self.dict.val->len)
	elif type == TP_LIST:
		return tp_number(self.list.val->len)
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_len) TypeError: len() of unsized object"));
	throw "TypeError in tp_ops.cpp:tp_len invalid object type to use the len function with"


def len(tp_obj self) ->int:
	int type = self.type.type_id
	if type == TP_STRING:
		return (int)(tp_string_len(self))
	elif type == TP_DICT:
		return (int)(self.dict.val->len)
	elif type == TP_LIST:
		return (int)(self.list.val->len)
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_len) TypeError: len() of unsized object"));
	throw "TypeError in tp_ops.cpp:len invalid object type to use the len function with"


def tp_cmp(TP, tp_obj a, tp_obj b) ->int:
	if a.type.type_id != b.type.type_id:
		if a.type.type_id==TP_INTEGER && b.type.type_id==TP_NUMBER:
			return _tp_sign_int(a.integer.val - (int)b.number.val)
		elif a.type.type_id==TP_NUMBER && b.type.type_id==TP_INTEGER:
			return _tp_sign_int( (int)a.number.val - b.integer.val);
		//std::cout << "first type: " << a.type.type_id << std::endl;
		//std::cout << "second type: " << b.type.type_id << std::endl;
		//throw "invalid compare of different types";
		return a.type.type_id-b.type.type_id; // why not just return false here?
	switch a.type.type_id:
		case TP_NONE: return 0;
		case TP_NUMBER: return _tp_sign(a.number.val-b.number.val);
		case TP_INTEGER: return _tp_sign_int(a.integer.val-b.integer.val);
		case TP_STRING: return tp_string_cmp(a, b);
		case TP_LIST: return tp_list_cmp(tp, a, b);
		case TP_DICT: return a.dict.val - b.dict.val;
		case TP_FUNC: return a.func.info - b.func.info;
		case TP_DATA: return (char*)a.data.val - (char*)b.data.val;
	//tp_raise(0,tp_string_atom(tp, "(tp_cmp) TypeError: ?"));
	throw "TypeError in tp_ops.cpp:tp_cmp invalid object type to compare for equality"


def tp_mod(TP, tp_obj a, tp_obj b) -> tp_obj:
	switch a.type.type_id:
		case TP_NUMBER:
			if b.type.type_id == TP_NUMBER:
				return tp_number(((long)a.number.val) % ((long)b.number.val))
			break
		case TP_STRING:
			return tp_ez_call(tp, "__builtins__", "format", tp_params_v(tp, 2, a, b))
	//tp_raise(tp_None, tp_string_atom(tp, "(tp_mod) TypeError: ?"));
	throw "TypeError in tp_ops.cpp:tp_mod invalid object type to use modulus operator with"



def tp_bitwise_and(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) & ((long)b) )
	throw "TypeError: operand type `bitwise and` requires numbers"

def tp_bitwise_or(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) | ((long)b) )
	throw "TypeError: operand type `bitwise or` requires numbers"


def tp_bitwise_xor(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) ^ ((long)b) )
	throw "TypeError: operand type `bitwise xor` requires numbers"


def tp_lsh(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) << ((long)b) )
	throw "TypeError: operand type `bitwise left shift` requires numbers"

def tp_rsh(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) >> ((long)b) )
	throw "TypeError: operand type `bitwise right shift` requires numbers"


def tp_sub(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) - ((long)b) )
	throw "TypeError: operand type `-` requires numbers"

def tp_div(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) / ((long)b) )
	throw "TypeError: operand type `/` requires numbers"

def tp_pow(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( pow(a,b) )
	throw "TypeError: operand type `**` requires numbers"


def tp_bitwise_not(TP, tp_obj a) ->tp_obj:
	if a.type.type_id == TP_NUMBER:
		return tp_number(~(long)a.number.val)
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_bitwise_not) TypeError: unsupported operand type"));
	throw "TypeError tp_ops.cpp:tp_bitwise_not unsupported operand type"


## Function: tp_call
## Calls a tinypy function.
## Use this to call a tinypy function.
## Parameters:
## tp - The VM instance.
## self - The object to call.
## params - Parameters to pass.
## Example:
## > tp_call(tp,
## >     tp_get(tp, tp->builtins, tp_string_atom(tp, "foo")),
## >     tp_params_v(tp, tp_string_atom(tp, "hello")))
## This will look for a global function named "foo", then call it with a single
## positional parameter containing the string "hello".

def tp_call(TP, tp_obj self, tp_obj params) ->tp_obj:
	#ifdef DEBUG
	  print("tp_call:")
	#endif
	## Im not sure we should have to do this, but just for giggles we will.
	tp->params = params
	if self.type.type_id == TP_INTERFACE:
		#ifdef DEBUG
		  print("	TP_INTERFACE")
		#endif
		tp_obj meta
		if tp_vget(tp, self, tp_string_atom(tp, "__new__"), &meta, 1):
			#ifdef DEBUG
			  print("	TP_INTERFACE has __new__")
			#endif
			tpd_list_insert(tp, params.list.val, 0, self)
			return tp_call(tp, meta, params)
		#ifdef DEBUG
		  print("	TP_INTERFACE missing __new__")
		#endif
	elif self.type.magic == TP_OBJECT:
		## TODO TEST AND FIX, shouldn't above be: `self.type.type_id==TP_OBJECT` ???
		#ifdef DEBUG
		  print("	TP_OBJECT __call__")
		#endif
		TP_META_BEGIN(self,"__call__")
		  return tp_call(tp, meta, params)
		TP_META_END
	if self.type.type_id == TP_FUNC:
		#ifdef DEBUG
		  print("	TP_FUNC")
		#endif
		if self.type.magic == TP_FUNC_MASK_CPP:
			#ifdef DEBUG
			  print("	TP_FUNC_MASK_CPP")
			#endif
			tp_obj r = self.func.info->cppfunc(tp)
			tp_grey(tp, r)
			return r
		elif self.type.magic == TP_FUNC_MASK_METHOD_CPP:
			#ifdef DEBUG
			  print("	TP_FUNC_MASK_METHOD_CPP")
			#endif
			tpd_list_insert(tp, tp->params.list.val, 0, self.func.info->instance)
			tp_obj r = self.func.info->cppfunc(tp)
			tp_grey(tp, r)
			return r
		elif not self.type.magic & TP_FUNC_MASK_C:
			#ifdef DEBUG
			  print("	TP_FUNC_MASK_C")
			#endif
			if self.type.magic & TP_FUNC_MASK_METHOD:
				tpd_list_insert(tp, tp->params.list.val, 0, self.func.info->instance)
			tp_obj (* cfunc)(tp_vm *)
			cfunc = (tp_obj (*)(tp_vm*))self.func.cfnc
			tp_obj r = cfunc(tp)
			tp_grey(tp, r)
			return r
		else:
			#ifdef DEBUG
			  print("	BYTECODE FUNCTION")
			#endif
			## compiled Python function
			tp_obj dest = tp_None
			tp_enter_frame(tp, self.func.info->globals,self.func.info->code, &dest)
			if self.type.magic & TP_FUNC_MASK_METHOD:
				tp->frames[tp->cur].regs[0] = params
				tpd_list_insert(tp, params.list.val, 0, self.func.info->instance)
			else:
				tp->frames[tp->cur].regs[0] = params
			tp_run_frame(tp)
			return dest
	//tp_echo(tp, self);
	print("ERROR in tp_call - object type: ")
	print(self.type.type_id)
	print("  object: ")
	print(tp_as_string(tp,self))
	print("  object type: ")
	print(self.type.type_id)
	print(" The most common cause of this error is the function is undefined,")
	print(" in rare cases this error can happen when TP_GCMAX or TP_REGS is not set high enough")
	print(" or when an interface is missing the meta function __new__")
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_call) TypeError: object is not callable"));
	throw "TypeError tp_ops.cpp:tp_call object is not callable"


## tp_obj methods

@const
def tp_obj::operator==(const char* s) ->bool:
	return std::string(tp_string_getptr(*this))==std::string(s);

@const
def tp_obj::operator char():
	return *tp_string_getptr(*this)

@const
def tp_obj::operator uint8_t():
	return (uint8_t)(*tp_string_getptr(*this))


def tp_obj::operator[] (int index) -> tp_obj:
	if this->type.type_id==TP_STRING:
		auto ptr = tp_string_getptr(*this)
		char c = ptr[index]
		//std::cout << c << std::endl;
		std::string s{c};
		return tp_string_from_stdstring(NULL,s)
	else:
		return _tp_get(NULL, *this, tp_number(index), 0)


def operator << (std::ostream &out, const tp_obj &self) -> std::ostream &:
	out << tp_as_string(NULL, self)
	return out


def tp_obj::append(const char *s):
	tp_obj ob = tp_string_from_const(NULL,s, strlen(s))
	tpd_list_append(NULL, this->list.val, ob)


def tp_obj::append(std::string s):
	tpd_list_append(NULL, this->list.val, tp_string_from_stdstring(NULL,s))

def tp_obj::append(double n):
	tpd_list_append(NULL, this->list.val, tp_number(n))

def tp_obj::append(int n):
	tpd_list_append(NULL, this->list.val, tp_number(n))

def tp_obj::append(tp_obj ob):
	tpd_list_append(NULL, this->list.val, ob)


