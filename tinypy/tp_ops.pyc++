## Pythonic++ helper functions ##
def len(char s[12]) ->int:
	int n = 0
	for i in range(12):
		if s[i]=='\0':
			break
		else:
			n ++
	return n

def len(tp_obj self) ->int:
	int type = self.type.type_id
	if type == TP_STRING_TINY:
		return len(self.str.val)
	elif type == TP_STRING_4BIT:
		return self.str4.len()
	elif type == TP_STRING:
		return (int)(tp_string_len(self))
	elif type == TP_STRING_ATOMIC:
		return (int)(tp_string_len(self))
	elif type == TP_DICT:
		return (int)(self.dict.val->len)
	elif type == TP_LIST:
		return (int)(self.list.val->len)
	elif type == TP_LIST_TINY:
		return (int)(self.lst.val->len())
	elif type == TP_VEC2:
		return 2
	elif type == TP_VEC3:
		return 3
	elif type == TP_QUAT:
		return 4
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_len) TypeError: len() of unsized object"));
	raise "TypeError in tp_ops.cpp:len invalid object type to use the len function with"

def len(const tp_obj *self) ->int:
	return len(*self)

def len(const char* s) ->int:
	return strlen(s)

def chr(int n) ->unsigned char:
	return (unsigned char)n

def ord(char c) ->int:
	return (int)((unsigned char)c)

def isstring(tp_obj ob) ->bool:
	if ob.type.type_id==TP_STRING_TINY:
		return true
	elif ob.type.type_id==TP_STRING_4BIT:
		return true
	elif ob.type.type_id == TP_STRING:
		return true
	elif ob.type.type_id==TP_STRING_ATOMIC:
		return true
	else:
		return false

def isstring(TPTypeID t)->bool:
	if t == TP_STRING_TINY:
		return true
	elif t == TP_STRING_4BIT:
		return true
	elif t == TP_STRING:
		return true
	elif t == TP_STRING_ATOMIC:
		return true
	else:
		return false


#ifndef SUPER_TINY


## Function: tp_true
## Check the truth value of an object
## Returns false if v is a numeric object with a value of exactly 0, v is of
## type None or v is a string list or dictionary with a length of 0. Else true
## is returned.
def tp_true(TP,tp_obj v) ->int:
	switch v.type.type_id:
		case TP_NUMBER: return v.number.val != 0;
		case TP_NONE: return 0;
		case TP_STRING: return tp_string_len(v) != 0;
		case TP_STRING_ATOMIC: return tp_string_len(v) != 0;
		case TP_LIST: return v.list.val->len != 0;
		case TP_DICT: return v.dict.val->len != 0;
	return 1;


## Function: tp_has
## Checks if an object contains a key.
## Returns tp_True if self[k] exists, tp_False otherwise.

def tp_has(TP,tp_obj self, tp_obj k) ->tp_obj:
	int type = self.type.type_id
	if type == TP_DICT or type == TP_INTERFACE:
		if tpd_dict_hashfind(tp, self.dict.val, tp_hash(tp, k), k) != -1:
			return tp_True
		return tp_False
	elif type == TP_STRING && k.type.type_id == TP_STRING:
		return tp_number(tp_str_index(self,k)!=-1)
	elif type == TP_LIST:
		return tp_number(tpd_list_find(tp, self.list.val, k, tp_cmp)!=-1)
	elif type == TP_SET:
		if self.uset.val->contains(k):
			return tp_number(1)
		else:
			return tp_number(0)
	print("======tp_has=======")
	print(self)
	print(k)
	raise "TypeError in tp_ops.cpp:tp_has iterable argument required"


## Function: tp_del
## Remove a dictionary entry.
## Removes the key k from self. Also works on classes and objects.
## Note that unlike with Python, you cannot use this to remove list items.
def tp_del(TP, tp_obj self, tp_obj k):
	int type = self.type.type_id
	#ifdef BLENDOT_TYPES
	if type == TP_SPATIAL:
		delete self.spatial.ptr
		return
	#endif
	if type == TP_DICT:
		tp_dict_del(tp, self, k)
		return
	##tp_raise(,tp_string_atom(tp, "(tp_del) TypeError: object does not support item deletion"));
	raise "TypeError in tp_ops.cpp:tp_del object does not support item deletion"


## Function: tp_iter
## Iterate through a list or dict.
## If self is a list/string/dictionary, this will iterate over the
## elements/characters/keys respectively, if k is an increasing index
## starting with 0 up to the length of the object-1.
## In the case of a list of string, the returned items will correspond to the
## item at index k. For a dictionary, no guarantees are made about the order.
## You also cannot call the function with a specific k to get a specific
## item -- it is only meant for iterating through all items, calling this
## function len(self) times. Use <tp_get> to retrieve a specific item, and
## <tp_len> to get the length.
##
## Parameters:
## self - The object over which to iterate.
## k - You must pass 0 on the first call, then increase it by 1 after each call,
##     and do not call the function with k >= len(self).
##
## Returns:
## The first (k = 0) or next (k = 1 .. len(self)-1) item in the iteration.

def tp_iter(TP,tp_obj self, tp_obj k) ->tp_obj:
	int type = self.type.type_id
	if type == TP_LIST or type == TP_STRING or type==TP_STRING_ATOMIC:
		return tp_get(tp,self,k)
	elif type == TP_LIST_TINY:
		return self.lst.val->items[ (int)k ]
	elif type == TP_STRING_4BIT:
		return tp_string_tiny( self.str4.as_string()[ (int)k ] )
	elif type == TP_DICT && k.type.type_id == TP_NUMBER:
		raise "TODO iter over dict"
		## the iter counter should be put on tp, instead of the dict itself,
		## because each thread had its own tp_vm, having the counter on it is ok.
		##return self.dict.val->items[tpd_dict_next(tp,self.dict.val)].key
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_iter) TypeError: iteration over non-sequence"));
	raise "TypeError in tp_ops.cpp:tp_iter iteration over a non-sequence";

## Function: tp_get
## Attribute lookup.
## 
## This returns the result of using self[k] in actual code. It works for
## dictionaries (including classes and instantiated objects), lists and strings.
##
## As a special case, if self is a list, self[None] will return the first
## element in the list and subsequently remove it from the list.

static tp_obj _tp_get(TP, tp_obj self, tp_obj k, int mget);

## lookup using []; never bind functions
def tp_get(TP, tp_obj self, tp_obj k) ->tp_obj:
	if defined(DEBUG):
		print(DYELLOW,"tp_get")
	##if self.type.type_id==TP_LIST and k.type.type_id==TP_NONE and self.list.val->len==0:
	##	print("	self.list.val->len =", self.list.val->len)
	##	throw "list[None] hack list len is zero - this should never happen"
	return _tp_get(tp, self, k, 0)

## lookup using .; always bind functions. FIXME: static and class binding
def tp_mget(TP, tp_obj self, tp_obj k) ->tp_obj:
	if defined(DEBUG):
		print(DYELLOW, "tp_mget")
	return _tp_get(tp, self, k, 1)

def tp_get_by_char(TP, tp_obj d, char c) ->tp_obj:
	//std::string s{c}
	//tp_obj key = tp_string_from_stdstring(tp, s)
	tp_obj key = tp_string_from_buffer(tp, (const char*)&c, 1)
	tp_obj item = tp_dict_get(tp, d, key)
	return item


def tp_set_by_char(TP, tp_obj self, char c, tp_obj value):
	//std::string s{c};
	//tp_obj key = tp_string_from_stdstring(tp, s);
	tp_obj key = tp_string_from_buffer(tp, (const char*)&c, 1)
	tp_dict_set(tp, self, key, value)


@static
def _tp_get(TP, tp_obj self, tp_obj k, int mget) -> tp_obj:
	if defined(DEBUG):
		print(self)
		print(DYELLOW, "------------------")
	auto type = self.type.type_id
	tp_obj r
	if type == TP_LIST:
		if k.type.type_id == TP_NUMBER:
			int l = tp_len(tp,self).number.val
			int n = k.number.val
			n = (n<0?l+n:n)
			return tpd_list_get(tp, self.list.val, n, "tp_get")
		elif isstring(k):
			#ifndef PURE_AOT
			##if tp_vget(tp, self, k, &r, 1):
			##	return r
			if k=="append":
				return tp_method(tp, self, tpy_list_append)
			elif k=="pop":
				return tp_method(tp, self, tpy_list_pop)
			elif k=="index":
				return tp_method(tp, self, tpy_list_index)
			elif k=="extend":
				return tp_method(tp, self, tpy_list_extend)
			elif k=="insert":
				return tp_method(tp, self, tpy_list_insert)
			else:
				print("invalid list method - self:")
				print(self)
				print("invalid list method - key:")
				print(k)
				raise "invalid list method"
			#endif
		elif k.type.type_id == TP_NONE:
			if defined(DEBUG):
				std::cout << cRed << "list.pop(None)" << cNone << std::endl;
			return tpd_list_pop(tp, self.list.val, 0, "tp_get")
	elif isstring(type):
		if k.type.type_id == TP_NUMBER:
			if type == TP_STRING_4BIT:
				return tp_string_tiny(self.str4[ (int)k.number.val ])
			else:
				int l = tp_string_len(self)
				int n = k.number.val
				n = (n<0?l+n:n)
				## this will crash with tiny strings TODO FIXME
				## TODO this should return a tiny string, this is where tp->chars which should be DEPRECATED
				##if (n >= 0 && n < l) { return tp_string_t_from_const(tp, tp->chars[(unsigned char) tp_string_getptr(self)[n]], 1); }
				return tp_string_tiny( tp_string_getptr(self)[n] )
		elif isstring(k.type.type_id):
			#ifndef PURE_AOT
			if k=="join":
				return tp_method(tp, self, tpy_str_join)
			elif k=="split":
				return tp_method(tp, self, tpy_str_split)
			elif k=="splitlines":
				return tp_method(tp, self, tpy_str_splitlines)
			elif k=="index":
				return tp_method(tp, self, tpy_str_index)
			elif k=="find":
				return tp_method(tp, self, tpy_str_find)
			elif k=="strip":
				return tp_method(tp, self, tpy_str_strip)
			elif k=="replace":
				return tp_method(tp, self, tpy_str_replace)
			elif k=="reverse":
				return tp_method(tp, self, tpy_str_reverse)
			elif k=="startswith":
				return tp_method(tp, self, tpy_str_startswith)
			elif k=="endswith":
				return tp_method(tp, self, tpy_str_endswith)
			else:
				print("------------------------")
				print(k)
				raise "invalid string method"
			#endif
	elif type == TP_VEC2:
		if k == "x":
			return tp_number(self.__vec2.vec.x)
		elif k == "y":
			return tp_number(self.__vec2.vec.y)
		#ifdef BLENDOT_TYPES
		elif k == "angle":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.__vec2.vec.angle())
			return tp_function(tp, fn)
		elif k == "aspect":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.__vec2.vec.aspect())
			return tp_function(tp, fn)
		elif k == "length":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.__vec2.vec.length())
			return tp_function(tp, fn)
		elif k == "normalized":
			## note, do not need to create a new tp_vec2 because this is already a copy
			auto fn = def[=](tp_vm *t):
				auto v = self
				v.__vec2.vec.normalize()
				return v
			return tp_function(tp, fn)
		#endif
		else:
			raise "vector2 missing member"
	elif type == TP_VEC3:
		if k.type.type_id == TP_NUMBER:
			if k.number.val == 0:
				return tp_number(self.__vec3.vec.x)
			elif k.number.val == 1:
				return tp_number(self.__vec3.vec.y)
			elif k.number.val == 2:
				return tp_number(self.__vec3.vec.z)
			else:
				raise "vec3 error - invalid index"
		elif k == "x":
			return tp_number(self.__vec3.vec.x)
		elif k == "y":
			return tp_number(self.__vec3.vec.y)
		elif k == "z":
			return tp_number(self.__vec3.vec.z)
		elif k == "length":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.__vec3.vec.length())
			return tp_function(tp, fn)
		elif k == "normalized":
			## note, do not need to create a new tp_vec3 because this is already a copy
			auto fn = def[=](tp_vm *t):
				auto v = self
				v.__vec3.vec.normalize()
				return v
			return tp_function(tp, fn)
		else:
			raise "vector3 missing member"
	elif type == TP_QUAT:
		if k == "x":
			return tp_number(self.__quat.q.x)
		elif k == "y":
			return tp_number(self.__quat.q.y)
		elif k == "z":
			return tp_number(self.__quat.q.z)
		elif k == "w":
			return tp_number(self.__quat.q.w)
		#ifdef BLENDOT_TYPES
		elif k == "length":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.__quat.q.length())
			return tp_function(tp, fn)
		elif k == "normalized":
			## note, do not need to create a new tp_vec2 because this is already a copy
			auto fn = def[=](tp_vm *t):
				auto v = self
				v.__quat.q.normalize()
				return v
			return tp_function(tp, fn)
		#endif
		else:
			raise "vec4/quat missing member"
	#ifdef BLENDOT_TYPES
	elif type == TP_COLOR:
		if k == "r":
			return tp_number(self.color.c🠊r)
		elif k == "g":
			return tp_number(self.color.c🠊g)
		elif k == "b":
			return tp_number(self.color.c🠊b)
		elif k == "a":
			return tp_number(self.color.c🠊a)
		elif k == "darkened":
			## note, do not need to create a new tp_vec2 because this is already a copy
			auto fn = def[=](TP):
				auto amount = TP_OBJ()
				auto v = self
				v.color.c🠊darkened(amount.number.val)
				return v
			return tp_function(tp, fn)
		else:
			raise "color missing member"
	elif type == TP_RECT:
		if k == "x":
			return tp_number(self.rect.r🠊position.x)
		elif k == "y":
			return tp_number(self.rect.r🠊position.y)
		elif k == "width":
			return tp_number(self.rect.r🠊size.x)
		elif k == "height":
			return tp_number(self.rect.r🠊size.y)
		elif k == "get_area":
			auto fn = def[=](tp_vm *t):
				return tp_number(self.rect.r🠊get_area())
			return tp_function(tp, fn)
		else:
			raise "rect missing member"
	elif type == TP_TRI:
		if k == "a":
			return tp_vec3(self.tri.t🠊vertex[0])
		elif k == "b":
			return tp_vec3(self.tri.t🠊vertex[1])
		elif k == "c":
			return tp_vec3(self.tri.t🠊vertex[2])
		else:
			raise "tri missing member"
	elif type == TP_PLANE:
		if k == "normal":
			return tp_vec3(self.plane.p🠊normal)
		elif k == "length":
			return tp_number(self.plane.p🠊d)
		elif k == "distance_to":
			auto fn = def[=](TP):
				auto point = TP_OBJ()
				return tp_number(self.plane.p🠊distance_to(point.__vec3.vec))
			return tp_function(tp, fn)
		else:
			raise "plane missing member"
	elif type == TP_AABB:
		if k == "position":
			return tp_vec3(self.aabb.a🠊position)
		elif k == "size":
			return tp_vec3(self.aabb.a🠊size)
		elif k == "merge":
			auto fn = def[=](TP):
				auto other = TP_OBJ()
				auto a = self
				a.aabb.a🠊merge( *other.aabb.a )
				return a
			return tp_function(tp, fn)
		else:
			raise "aabb missing member"
	elif type == TP_SPATIAL:
		if k == "position":
			return tp_vec3(self.spatial.ptr🠊get_translation())
		elif k == "rotation":
			return tp_vec3(self.spatial.ptr🠊get_rotation_degrees())
		elif k == "scale":
			return tp_vec3(self.spatial.ptr🠊get_scale())
		elif k == "set_position":
			auto fn = def[=](TP):
				auto ob = TP_OBJ()
				self.spatial.ptr🠊set_translation(ob.__vec3.vec)
				return self
			return tp_function(tp, fn)
		elif k == "set_rotation":
			auto fn = def[=](TP):
				auto ob = TP_OBJ()
				self.spatial.ptr🠊set_rotation_degrees(ob.__vec3.vec)
				return self
			return tp_function(tp, fn)
		elif k == "set_scale":
			auto fn = def[=](TP):
				auto ob = TP_OBJ()
				self.spatial.ptr🠊set_scale(ob.__vec3.vec)
				return self
			return tp_function(tp, fn)
		else:
			raise "spatial missing member"
	#endif
	if type >= TP_HAS_META:
		if type == TP_DICT:
			## '.' looks for methods of a raw dict.
			## [] looks for members
			if mget:
				if tp_vget(tp, self, k, &r, 1):
					return r
			else:
				return tp_dict_get(tp, self, k)
		elif type == TP_OBJECT:
			## not a raw dict, must be object or interface
			if defined(DEBUG):
				print(DORANGE, "	_tp_get on an object ")
			## calling TP_META_BEGIN is slow, instead __getitem__ should be checked for just once,
			## then if found it could use self.type.magic
			##TP_META_BEGIN(self,"__getitem__")
			##  return tp_call(tp, meta, tp_params_v1(tp, k))
			##TP_META_END
			if tp_vget(tp, self, k, &r, mget):
				return r
	elif type == TP_INTERFACE:
		if tp_vget(tp, self, k, &r, 0):
			return r
		elif self.type.magic == TP_MODULE_EXTERNAL_MAGIC:
			## fallback to slower lookup for external modules,
			## note if an interface is not a module, then its a class def
			return tpd_dict_get_by_stdstring(tp, self.dict.val, std::string(k))
		else:
			print(DRED, "GET ERROR: on TP_INTERFACE")
			std::cout << "key=" << k << " hash=" << tp_hash(NULL, k) << std::endl;
	elif type == TP_POINTER:
		if defined(DEBUG):
			print(DRED, "get from pointer->__methods__")
			print( std::string(k) )
		return static_cast<tpy_subclass*>(self.pointer.val)->__methods__[ std::string(k) ]
	elif k.type.type_id == TP_LIST:
		## deal with list / string keys on any unknown types - TODO check how this is used
		int a,b,l
		tp_obj tmp
		l = tp_len(tp,self).number.val
		tmp = tp_get(tp,k,tp_number(0))
		if tmp.type.type_id == TP_NUMBER:
			a = tmp.number.val
		elif tmp.type.type_id == TP_NONE:
			a = 0
		else:
			//tp_raise(tp_None,tp_string_atom(tp, "(tp_get) TypeError: indices must be numbers")); 
			raise "TypeError in tp_ops.cpp:_tp_get indices must be a number"
		tmp = tp_get(tp,k,tp_number(1))
		if tmp.type.type_id == TP_NUMBER:
			b = tmp.number.val
		elif tmp.type.type_id == TP_NONE:
			b = l
		else:
			//tp_raise(tp_None,tp_string_atom(tp, "(tp_get) TypeError: indices must be numbers")); 
			raise "TypeError in tp_ops.cpp:_tp_get indices must be a number"
		a = _tp_max(0,(a<0?l+a:a))
		b = _tp_min(l,(b<0?l+b:b))
		if type == TP_LIST:
			return tp_list_from_items(tp,b-a,&self.list.val->items[a])
		##elif type == TP_STRING:  ## what syntax was this? slice a string with a list? TODO check me
		##	return tp_string_view(tp,self,a,b)
	##elif k.type.type_id == TP_STRING:
	##	## this is not correct, unknowntype.foo should not return unknowntype
	##	return tp_copy(tp, self)
	std::cout << cRed << "GET ERROR: type = " << cNone << self.type.type_id << std::endl;
	std::cout << cRed << "GET ERROR: self = " << cNone << self << std::endl;
	std::cout << cRed << "GET ERROR: key =" << cNone << k << cBlue << " hash=" << tp_hash(tp,k) << cNone << std::endl;
	raise "GET ERROR - in tp_ops.cpp - unexpected type or invalid key/index"

## function: tp_copy
def tp_copy(TP, tp_obj self) -> tp_obj:
	int type = self.type.type_id
	if type == TP_NUMBER:
		return self
	elif type == TP_INTEGER:
		return self
	elif type == TP_VEC2:
		return self
	elif type == TP_VEC3:
		return self
	elif type == TP_STRING:
		return tp_string_from_buffer(tp, tp_string_getptr(self), tp_string_len(self))
	elif type == TP_LIST:
		return tp_list_copy(tp, self)
	elif type == TP_DICT || type == TP_INTERFACE || type == TP_OBJECT:
		return tp_dict_copy(tp, self)
	//tp_raise(tp_None, tp_string_atom(tp, "(tp_copy) TypeError: object does not support copy"));
	raise "TypeError in tp_ops.cpp:tp_copy object does not support copy"



## Function: tp_iget
## Failsafe attribute lookup.
## This is like <tp_get>, except it will return false if the attribute lookup
## failed. Otherwise, it will return true, and the object will be returned
## over the reference parameter r.

def tp_iget(TP,tp_obj *r, tp_obj self, tp_obj k) ->int:
	if self.type.type_id == TP_DICT || self.type.type_id == TP_OBJECT || self.type.type_id == TP_INTERFACE:
		int n = tpd_dict_hashfind(tp, self.dict.val, tp_hash(tp, k), k)
		if n == -1:
			return 0
		*r = self.dict.val->items[n].val
		tp_grey(tp,*r)
		return 1
	if self.type.type_id == TP_LIST && !self.list.val->len:
		return 0
	*r = tp_get(tp,self,k)
	tp_grey(tp,*r)
	return 1;


## Function: tp_set
## Attribute modification.
## This is the counterpart of tp_get, it does the same as self[k] = v would do
## in actual tinypy code.

def tp_set(TP,tp_obj self, tp_obj k, tp_obj v) -> tp_obj:
	int type = self.type.type_id
	#ifdef BLENDOT_TYPES
	if type == TP_COLOR:
		if k == "r":
			self.color.c🠊r = v.number.val
		elif k == "g":
			self.color.c🠊g = v.number.val
		elif k == "b":
			self.color.c🠊b = v.number.val
		elif k == "a":
			self.color.c🠊a = v.number.val
		else:
			raise "color type missing member"
		return self
	elif type == TP_RECT:
		if k == "x":
			self.rect.r🠊position.x = v.number.val
		elif k == "y":
			self.rect.r🠊position.y = v.number.val
		elif k == "width":
			self.rect.r🠊size.x = v.number.val
		elif k == "height":
			self.rect.r🠊size.y = v.number.val
		else:
			raise "rect type missing member"
		return self
	elif type == TP_TRI:
		if k == "a":
			self.tri.t🠊vertex[0] = v.__vec3.vec
		elif k == "b":
			self.tri.t🠊vertex[1] = v.__vec3.vec
		elif k == "c":
			self.tri.t🠊vertex[2] = v.__vec3.vec
		else:
			raise "tri type missing member"
		return self
	#endif
	if type == TP_DICT:
		tp_dict_set(tp, self, k, v)
		return self
	elif type == TP_LIST:
		if k.type.type_id == TP_NUMBER:
			tpd_list_set(tp, self.list.val, k.number.val, v, "tp_set")
			return self
		elif k.type.type_id == TP_NONE:
			tpd_list_append(tp, self.list.val, v)
			return self
		elif k.type.type_id == TP_STRING:
			## WTF is this syntax? a['*'] = b will extend a by b ??
			## FIXME: remove this support. Use a + b
			if tp_cmp(tp, tp_string_atom(tp, "*"), k) == 0:
				tpd_list_extend(tp, self.list.val, v.list.val)
				return self
	elif type == TP_INTERFACE:
		tp_dict_set(tp, self, k, v)
		return self
	elif type == TP_OBJECT:
		## TODO
		##TP_META_BEGIN(self,"__set__")
		##  tp_call(tp,meta,tp_params_v2(tp,k,v))
		##  return self
		##TP_META_END
		tp_dict_set(tp, self, k, v)
		return self
	elif type == TP_VEC2:
		if k == "x":
			self.__vec2.vec.x = v.number.val
		elif k == "y":
			self.__vec2.vec.y = v.number.val
		else:
			raise "vector2 type missing member"
		return self
	elif type == TP_VEC3:
		if k == "x":
			self.__vec3.vec.x = v.number.val
		elif k == "y":
			self.__vec3.vec.y = v.number.val
		elif k == "z":
			self.__vec3.vec.z = v.number.val
		else:
			raise "vector3 type missing member"
		return self
	elif type == TP_QUAT:
		if k == "x":
			self.__quat.q.x = v.number.val
		elif k == "y":
			self.__quat.q.y = v.number.val
		elif k == "z":
			self.__quat.q.z = v.number.val
		elif k == "w":
			self.__quat.q.w = v.number.val
		else:
			raise "vec4/quat type missing member"
		return self
	##tp_raise(,tp_string_atom(tp, "(tp_set) TypeError: object does not support item assignment"));
	print("======================================")
	print(self)
	print("self object type_id = ", self.type.type_id)
	print(k)
	print("TypeError in tp_ops.cpp:tp_set object does not support item assignment")
	raise "TypeError in tp_ops.cpp:tp_set object does not support item assignment"


## used by modules, strings are not interned with 8bit hashes even though v is required to be a tiny string ##
def tp_set(TP,tp_obj self, tp_obj k, const char* v) -> tp_obj:
	if strlen(v) > 12:
		print("tp_set(obj, key, string) - string is more than 12 bytes")
		raise "tp_set(obj, key, string) - string is more than 12 bytes"
	## need to check here if v has already been 8bit hashed? because some modules may use internal names
	return tp_set(tp, self, k, tp_string_tiny(v))


## used by modules, strings are not interned with 8bit hashes even though k is required to be a tiny string ##
def tp_set(TP,tp_obj self, const char* k, tp_obj v) -> tp_obj:
	if strlen(k) > 12:
		print(k)
		print("tp_set(obj, string key, value) - string key is more than 12 bytes")
		raise "tp_set(obj, string key, value) - string key is more than 12 bytes"
	## need to check here if v has already been 8bit hashed? because some modules may use internal names
	return tp_set(tp, self, tp_string_tiny(k), v)

def tp_set(TP,tp_obj self, const char* k, const char* v) -> tp_obj:
	if strlen(k) > 12:
		print("tp_set(obj, string key, string value) - string key is more than 12 bytes")
		raise "tp_set(obj, string key, string value) - string key is more than 12 bytes"
	if strlen(v) > 12:
		print("tp_set(obj, string key, string value) - string value is more than 12 bytes")
		raise "tp_set(obj, string key, string value) - string value is more than 12 bytes"
	return tp_set(tp, self, tp_string_tiny(k), tp_string_tiny(v) )


#######################################################################
def tp_add(TP, tp_obj a, tp_obj b) -> tp_obj:
	if a.type.type_id == TP_NUMBER && a.type.type_id == b.type.type_id:
		return tp_number(a.number.val+b.number.val)
	elif a.type.type_id == TP_STRING && a.type.type_id == b.type.type_id:
		return tp_string_add(tp, a, b)
	elif a.type.type_id == TP_LIST && a.type.type_id == b.type.type_id:
		return tp_list_add(tp, a, b)
	elif a.type.type_id == TP_VEC2 && a.type.type_id == b.type.type_id:
		## a is already a copy
		a.__vec2.vec = a.__vec2.vec + b.__vec2.vec
		return a
	elif a.type.type_id == TP_VEC3 && a.type.type_id == b.type.type_id:
		## a is already a copy
		a.__vec3.vec = a.__vec3.vec + b.__vec3.vec
		return a
	#ifdef BLENDOT_TYPES
	elif a.type.type_id == TP_QUAT && a.type.type_id == b.type.type_id:
		## a is already a copy
		##TODO fixme##a.quat.q = &((*a.quat.q) + (*b.quat.q))
		return a
	#endif
	##tp_raise(tp_None,tp_string_atom(tp, "(tp_add) TypeError: ?"));
	print("operand A::type_id ")
	print(a.type.type_id)
	print("operand B::type_id ")
	print(b.type.type_id)
	raise "TypeError in tp_ops.cpp:tp_add invalid object type to use the add operator with"


def tp_mul(TP,tp_obj a, tp_obj b) -> tp_obj:
	if a.type.type_id == TP_NUMBER && a.type.type_id == b.type.type_id:
		return tp_number(a.number.val*b.number.val)
	if a.type.type_id == TP_NUMBER:
		## TODO what cases are this for?
		tp_obj c = a; a = b; b = c
	if a.type.type_id == TP_STRING_TINY && b.type.type_id == TP_NUMBER:
		int n = b.number.val
		return tp_string_mul(tp, a, n)
	if a.type.type_id == TP_STRING && b.type.type_id == TP_NUMBER:
		int n = b.number.val
		return tp_string_mul(tp, a, n)
	if a.type.type_id == TP_LIST && b.type.type_id == TP_NUMBER:
		int n = b.number.val
		return tp_list_mul(tp, a, n)
	#ifdef BLENDOT_TYPES
	if a.type.type_id == TP_MAT3:
		## note `a` is already a copy
		*a.mat3.m *= *b.mat3.m
		return a
	#endif
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_mul) TypeError: ?"));
	raise "TypeError in tp_ops.cpp:tp_mul invalid object type to use the multiply operator with"


## Function: tp_len
## Returns the length of an object.
## Returns the number of items in a list or dict, or the length of a string.
def tp_len(TP,tp_obj self) -> tp_obj:
	int type = self.type.type_id;
	if type == TP_STRING_TINY:
		##note: do not call strlen directly, because it reads until it hits a null byte, but max is 12
		##return tp_number( strlen(self.str.val) )
		return tp_number( len(self.str.val) )
	elif type == TP_STRING_4BIT:
		return tp_number( self.str4.len() )
	elif type == TP_STRING:
		return tp_number(tp_string_len(self))
	elif type == TP_DICT:
		return tp_number(self.dict.val->len)
	elif type == TP_LIST:
		return tp_number(self.list.val->len)
	elif type == TP_LIST_TINY:
		return tp_number(self.lst.val->len() )
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_len) TypeError: len() of unsized object"));
	raise "TypeError in tp_ops.cpp:tp_len invalid object type to use the len function with"


def tp_cmp(TP, tp_obj a, tp_obj b) ->int:
	if a.type.type_id != b.type.type_id:
		if a.type.type_id==TP_INTEGER && b.type.type_id==TP_NUMBER:
			return _tp_sign_int(a.integer.val - (int)b.number.val)
		elif a.type.type_id==TP_NUMBER && b.type.type_id==TP_INTEGER:
			return _tp_sign_int( (int)a.number.val - b.integer.val);
		elif isstring(a) and isstring(b):
			return tp_string_cmp(a,b)
		//std::cout << "first type: " << a.type.type_id << std::endl;
		//std::cout << "second type: " << b.type.type_id << std::endl;
		//throw "invalid compare of different types";
		return a.type.type_id-b.type.type_id; // why not just return false here?
	switch a.type.type_id:
		case TP_NONE: return 0;
		case TP_NUMBER: return _tp_sign(a.number.val-b.number.val);
		case TP_INTEGER: return _tp_sign_int(a.integer.val-b.integer.val);
		case TP_STRING: return tp_string_cmp(a, b);
		case TP_STRING_TINY: return tp_string_cmp(a, b);
		case TP_LIST: return tp_list_cmp(tp, a, b);
		case TP_DICT: return a.dict.val - b.dict.val;
		case TP_FUNC: return a.func.info - b.func.info;
		##case TP_DATA: return (char*)a.data.val - (char*)b.data.val;
	//tp_raise(0,tp_string_atom(tp, "(tp_cmp) TypeError: ?"));
	raise "TypeError in tp_ops.cpp:tp_cmp invalid object type to compare for equality"




def tp_mod(TP, tp_obj a, tp_obj b) -> tp_obj:
	switch a.type.type_id:
		case TP_NUMBER:
			if b.type.type_id == TP_NUMBER:
				return tp_number(((long)a.number.val) % ((long)b.number.val))
			break
		case TP_STRING_TINY:
			auto parts = split_tiny_string_as_stdvec(a, "%s")
			int i = 0
			std::string out = std::string("")
			for (auto & part : parts):
				out += part
				if i+1 == parts.size():
					break
				if b.type.type_id == TP_LIST:
					if i >= b.list.val->len:
						raise "string format error - replacement marks `%s` is greater than items from list"
					out += tp_as_string(tp, b.list.val->items[i], false)
				else:
					out += tp_as_string(tp, b, false)
				i ++
			return tp_string_from_stdstring(tp, out )
			break
		case TP_STRING:
			//return tp_ez_call(tp, "__builtins__", "format", tp_params_v2(tp, a, b)) // DEPRECATED
			auto parts = __split_string__(a, std::string("%s"))
			int i = 0
			std::string out = std::string("")
			for (auto & part : parts):
				out += part
				if i+1 == parts.size():
					break
				if b.type.type_id == TP_LIST:
					if i >= b.list.val->len:
						raise "string format error - replacement marks `%s` is greater than items from list"
					out += tp_as_string(tp, b.list.val->items[i], false)
				else:
					out += tp_as_string(tp, b, false)
				i ++
			return tp_string_from_stdstring(tp, out )
			break
	//tp_raise(tp_None, tp_string_atom(tp, "(tp_mod) TypeError: ?"));
	raise "TypeError in tp_ops.cpp:tp_mod invalid object type to use modulus operator with"



def tp_bitwise_and(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( (int)(((long)a) & ((long)b)) )
	raise "TypeError: operand type `bitwise and` requires numbers"

def tp_bitwise_or(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) | ((long)b) )
	raise "TypeError: operand type `bitwise or` requires numbers"


def tp_bitwise_xor(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) ^ ((long)b) )
	raise "TypeError: operand type `bitwise xor` requires numbers"


def tp_lsh(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) << ((long)b) )
	raise "TypeError: operand type `bitwise left shift` requires numbers"

def tp_rsh(TP,tp_obj _a,tp_obj _b) ->tp_obj:
	if _a.type.type_id == TP_NUMBER && _a.type.type_id == _b.type.type_id:
		tp_num a = _a.number.val
		tp_num b = _b.number.val
		return tp_number( ((long)a) >> ((long)b) )
	raise "TypeError: operand type `bitwise right shift` requires numbers"


def tp_sub(TP,tp_obj a, tp_obj b) ->tp_obj:
	if a.type.type_id == TP_NUMBER && a.type.type_id == b.type.type_id:
		return tp_number( a.number.val - b.number.val )
	raise "TypeError: operand type `-` requires numbers"

def tp_div(TP,tp_obj a, tp_obj b) ->tp_obj:
	if a.type.type_id == TP_NUMBER && a.type.type_id == b.type.type_id:
		return tp_number( a.number.val / b.number.val )
	else:
		print(a)
		print(b)
	raise "TypeError: operand type `/` requires numbers"

def tp_pow(TP,tp_obj a,tp_obj b) ->tp_obj:
	if a.type.type_id == TP_NUMBER && a.type.type_id == b.type.type_id:
		return tp_number( pow(a.number.val, b.number.val) )
	raise "TypeError: operand type `**` requires numbers"


def tp_bitwise_not(TP, tp_obj a) ->tp_obj:
	if a.type.type_id == TP_NUMBER:
		return tp_number(~(long)a.number.val)
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_bitwise_not) TypeError: unsupported operand type"));
	raise "TypeError tp_ops.cpp:tp_bitwise_not unsupported operand type"

## end of SUPER_TINY
#endif

## Function: tp_call
## Calls a tinypy function.
## Use this to call a tinypy function.
## Parameters:
## tp - The VM instance.
## self - The object to call.
## params - Parameters to pass.
## Example:
## > tp_call(tp,
## >     tp_get(tp, tp->builtins, tp_string_atom(tp, "foo")),
## >     tp_params_v(tp, tp_string_atom(tp, "hello")))
## This will look for a global function named "foo", then call it with a single
## positional parameter containing the string "hello".

#ifndef PURE_AOT

def tp_call(TP, tp_obj self, tp_obj params) ->tp_obj:
	if defined(DEBUG) or defined(DEBUG_CALLS):
		print("----------tp_call-----------")
		##print("--------tp_ops.pyc++ - tp_call params:")
		##TODO FIXME##print(params)  ## segfaults here sometimes - malloc error
	## Im not sure we should have to do this, but just for giggles we will.
	tp->params = params
	if self.type.type_id == TP_INTERFACE:
		if defined(DEBUG) or defined(DEBUG_CALLS):
			print("	call - TP_INTERFACE")
		##tp_obj meta
		##if tp_vget(tp, self, tp_string_atom(tp, "__new__"), &meta, 1):
		##	if defined(DEBUG):
		##		print("	call - TP_INTERFACE has __new__")
		##	tpd_list_insert(tp, params.list.val, 0, self)
		##	return tp_call(tp, meta, params)
		##if defined(DEBUG):
		##  print("	call - TP_INTERFACE missing __new__")
		tp_obj __init__ = None
		tp_obj inst = tp_object(tp)
		inst.obj.info->meta = self
		tp_obj k = ATOM_INIT
		##int ihash = tp_hash(tp, k)
		##int n = tpd_dict_hashfind(tp, self.dict.val, ihash, k)
		##if n < 0:
		##	tp_obj __base__ = tp_dict_get(tp, self, tp_string_atom(tp,"__base__"))
		##	n = tpd_dict_hashfind(tp, __base__.dict.val, ihash, k)
		##	if n < 0:
		##		print(__base__)
		##		throw "can not find __init__ method on base class"
		##	else:
		##		__init__ = tpd_dict_get(tp, __base__.dict.val, n)
		##else:
		##	__init__ = tpd_dict_get(tp, self.dict.val, n)
		if tp_vget(tp, self, k, &__init__, 0):
			##__init__.func.info->instance = inst
			##return tp_call(tp, __init__, params)  ## this will fail because all __init__ functions always bypass the params list
			##tp_enter_frame(tp, __init__.func.info->globals, __init__.func.info->code, &inst)  ## note: it is wrong to pass &inst here because it gets set to None
			tp_enter_frame(tp, __init__.func.info->code, 0)
			tp->frames[tp->cur].regs[0] = inst
			for i in range( len(params) ):
				tp->frames[tp->cur].regs[i+1] = params[i]
			tp_run_frame(tp)
		## TODO params should be freed here?
		return inst
	elif self.type.magic == TP_OBJECT:
		## TODO TEST AND FIX, shouldn't above be: `self.type.type_id==TP_OBJECT` ???
		if defined(DEBUG) or defined(DEBUG_CALLS):
			print("	TP_OBJECT __call__")
		TP_META_BEGIN(self,"__call__")
		  return tp_call(tp, meta, params)
		TP_META_END
	if self.type.type_id == TP_FUNC:
		if defined(DEBUG) or defined(DEBUG_CALLS):
			print("____________call - TP_FUNC_____________")
		if self.type.magic == TP_FUNC_MAGIC_CPP:
			if defined(DEBUG) or defined(DEBUG_CALLS):
				print("	TP_FUNC_MAGIC_CPP")
			tp_obj r = self.func.info->cppfunc(tp)
			tp_grey(tp, r)
			return r
		##elif self.type.magic == TP_FUNC_MASK_METHOD_CPP:
		##	if defined(DEBUG) or defined(DEBUG_CALLS):
		##		print("	TP_FUNC_MASK_METHOD_CPP")
		##	tpd_list_insert(tp, tp->params.list.val, 0, self.func.info->instance)
		##	tp_obj r = self.func.info->cppfunc(tp)
		##	tp_grey(tp, r)
		##	return r
		##elif not self.type.magic & TP_FUNC_MASK_C:
		elif self.type.magic == TP_FUNC_MAGIC_C:
			if defined(DEBUG) or defined(DEBUG_CALLS):
				print("	TP_FUNC_MAGIC_C")
			##if self.type.magic & TP_FUNC_MASK_METHOD:
			if self.func.info->instance.type.type_id != TP_NONE:
				if defined(TINY_LIST_PARAMS):
					tp->params.lst.val->push_front(self.func.info->instance)
				else:
					tpd_list_insert(tp, tp->params.list.val, 0, self.func.info->instance)
				#########################################################################
			tp_obj (* cfunc)(tp_vm *)
			##cfunc = (tp_obj (*)(tp_vm*))self.func.cfnc
			cfunc = (tp_obj (*)(tp_vm*))self.func.info->cfunc
			tp_obj r = cfunc(tp)
			tp_grey(tp, r)
			return r
		elif self.type.magic == TP_FUNC_BYTECODE:
			if defined(DEBUG) or defined(DEBUG_CALLS):
				print(DYELLOW, "============= calling BYTECODE FUNCTION ==============")
				print(params)
			## compiled Python function
			tp_obj dest = tp_None
			tp_enter_frame(tp, self.func.info->code, &dest)
			##if self.type.magic & TP_FUNC_MASK_METHOD:
			##if self.type.magic == 3:
			if self.func.info->instance.type.type_id != TP_NONE:
				#ifdef TINY_LIST_PARAMS
				  params.lst.val->push_front(self.func.info->instance)
				#else
				  tpd_list_insert(tp, params.list.val, 0, self.func.info->instance)
				#endif
				tp->frames[tp->cur].regs[0] = params
			else:
				tp->frames[tp->cur].regs[0] = params
			tp_run_frame(tp)
			if defined(DEBUG) or defined(DEBUG_CALLS):
				print(DGREEN, "=============BYTECODE FUNCTION OK ==============")
			return dest
	//tp_echo(tp, self);
	print("ERROR in tp_call - object type: ")
	print(self.type.type_id)
	print("  object: ")
	print(tp_as_string(tp,self))
	print("  object type: ")
	print(self.type.type_id)
	print(" The most common cause of this error is the function is undefined,")
	print(" in rare cases this error can happen when TP_GCMAX or TP_REGS is not set high enough")
	print(" or when an interface is missing the meta function __new__")
	//tp_raise(tp_None,tp_string_atom(tp, "(tp_call) TypeError: object is not callable"));
	raise "TypeError tp_ops.cpp:tp_call object is not callable"

## end of PURE_AOT
#endif

## tp_obj methods ##

def tp_obj::tp_obj( const char* s ):
	*this = tp_string_from_stdstring(NULL, s )
	this->type.type_id = TP_STRING

def tp_obj::operator() (std::vector<tp_obj> args) ->tp_obj:
	#ifdef PURE_AOT
	raise "can not call bytecode functions in pure AOT mode"
	#else
	__tpvm_global__->params.lst.val->clear()
	for arg in args:
		__tpvm_global__->params.lst.val->append(arg)
	return tp_call(__tpvm_global__, *this, __tpvm_global__->params)
	#endif

def tp_obj::operator=(int n) ->tp_obj:
	this->type.type_id = TP_NUMBER
	this->number.val = n
	return *this

@const
def tp_obj::operator==(const char* s) ->bool:
	if this->type.type_id==TP_STRING_TINY:
		int lena = len(this)
		int lenb = len(s)
		if lena != lenb:
			return false
		for i in range(lena):
			if this->str.val[i] != s[i]:
				return false
		return true
	else:
		return std::string(*this)==std::string(s);

@const
def tp_obj::operator==(const tp_obj other) ->bool:
	if other.type.type_id==TP_NONE:
		if this->type.type_id==TP_NONE:
			return true
		elif this->type.type_id == TP_POINTER:
			if this->pointer.val == NULL:
				return true
		return false
	elif this->type.type_id==TP_POINTER and other.type.type_id==TP_POINTER:
		return this->pointer.val == other.pointer.val
	elif isstring(this->type.type_id):
		if not isstring(other.type.type_id):
			return false
		return std::string(*this) == std::string(other)
	elif this->type.type_id==TP_NUMBER:
		if other.type.type_id != TP_NUMBER:
			return false
		return this->number.val == other.number.val
	else:
		raise "TODO == op for some object type"

@const
def tp_obj::operator bool():
	if this->type.type_id == TP_NONE:
		return false
	elif this->type.type_id == TP_POINTER:
		if this->pointer.val == NULL:
			return false
		else:
			return true
	elif this->number.val == 0.0:
		return false
	else:
		return true


@const
def tp_obj::operator int():
	return (int)this->number.val

@const
def tp_obj::operator float():
	return this->number.val

@const
def tp_obj::operator std::string():
	if this->type.type_id == TP_STRING_TINY:
		##return std::string( (const char*)&this->str.val, len(this->str.val) )
		return std::string( (const char*)&this->str.val, tp_string_tiny_len(*this) )
	else:
		return std::string( tp_string_getptr(*this) )


##@const
##def tp_obj::operator const char*():
##	return tp_string_getptr(*this)

@const
def tp_obj::operator char():
	return *tp_string_getptr(*this)

@const
def tp_obj::operator uint8_t():
	return (uint8_t)(*tp_string_getptr(*this))

def tp_obj::set( const char* s, tp_obj ob) ->tp_obj:
	#ifdef SUPER_TINY
	tp_dict_set(NULL, *this, tp_string_tiny(s), ob)
	#else
	tp_set(NULL, *this, s, ob )
	#endif
	return None

def tp_obj::set( const char* s, const char* val) ->tp_obj:
	#ifdef SUPER_TINY
	tp_dict_set(NULL, *this, tp_string_tiny(s), tp_string_tiny(val))
	#else
	tp_set(NULL, *this, s, val )
	#endif
	return None

def tp_obj::operator[] (const char* s) -> tp_obj:
	return tpd_dict_get_by_stdstring(NULL, this->dict.val, std::string(s))


def tp_obj::operator[] (int index) -> tp_obj:
	if this->type.type_id==TP_STRING_TINY:
		return tp_string_tiny( this->str.val[index] )
	elif this->type.type_id==TP_STRING or this->type.type_id==TP_STRING_ATOMIC:
		auto ptr = tp_string_getptr(*this)
		char c = ptr[index]
		//std::cout << c << std::endl;
		std::string s{c};
		return tp_string_from_stdstring(NULL,s)
	elif this->type.type_id==TP_LIST_TINY:
		return this->lst.val->items[index]
	elif this->type.type_id==TP_LIST:
		return this->list.val->items[index]
	elif this->type.type_id==TP_VEC2:
		if index==0:
			return this->__vec2.vec.x
		elif index==1:
			return this->__vec2.vec.y
		else:
			raise "vec2 invalid index"
	elif this->type.type_id==TP_VEC3:
		if index==0:
			return this->__vec3.vec.x
		elif index==1:
			return this->__vec3.vec.y
		elif index==2:
			return this->__vec3.vec.z
		else:
			raise "vec3 invalid index"
	elif this->type.type_id==TP_QUAT:
		if index==0:
			return (double)this->__quat.q.x
		elif index==1:
			return (double)this->__quat.q.y
		elif index==2:
			return (double)this->__quat.q.z
		elif index==3:
			return (double)this->__quat.q.w
		else:
			raise "vec4/quat invalid index"
	else:
		#ifdef SUPER_TINY
		raise "tp_obj::operator[] error: unknown type"
		#else
		return _tp_get(NULL, *this, tp_number(index), 0)
		#endif

#ifndef SUPER_TINY
def operator << (std::ostream &out, const tp_obj &self) -> std::ostream &:
	out << tp_as_string(NULL, self)
	return out
#endif

def tp_obj::reverse() ->tp_obj:
	##TODO
	return *this

def tp_obj::contains(int n) ->bool:
	if this->type.type_id == TP_SET:
		if this->uset.val->numset.count( (float)n ) > 0:
			return true
		else:
			return false
	raise "invalid self type for tp_obj::contains"


def tp_obj::append(const char *s):
	tp_obj ob = tp_string_from_const(NULL,s, strlen(s))
	tpd_list_append(NULL, this->list.val, ob)


def tp_obj::append(std::string s):
	tpd_list_append(NULL, this->list.val, tp_string_from_stdstring(NULL,s))

def tp_obj::append(double n):
	tpd_list_append(NULL, this->list.val, tp_number(n))

def tp_obj::append(int n):
	tpd_list_append(NULL, this->list.val, tp_number(n))

def tp_obj::append(tp_obj ob):
	tpd_list_append(NULL, this->list.val, ob)

def tp_obj::as_vector() -> std::vector<tp_obj>:
	std::vector<tp_obj> r;
	if this🠊type.type_id == TP_LIST:
		for (int i=0; i < this🠊list.val🠊len; i++ ):
			r.push_back( this🠊list.val🠊items[i] )
	elif this🠊type.type_id == TP_LIST_TINY:
		for (int i=this🠊lst.val🠊start; i<this🠊lst.val🠊end; i++):
			r.push_back( this🠊lst.val🠊items[i] )
	elif this🠊type.type_id == TP_STRING:
		std::string str = std::string(*this)
		for (const char c: str):
			r.push_back( tp_string_tiny(c) )
	else:
		print( *this )
		raise "tp_obj::as_vector can only be used on a list and dict types"
	return r

def tp_obj::as_string()->std::string:
	return tp_as_string(NULL, *this, False)

def tp_obj::as_cstring()->const char*:
	return tp_as_string(NULL, *this, False).c_str()


def tp_set_pointer(void *ptr) -> int:
	if __tpy_rpointers__.count(ptr) > 0:
		return __tpy_rpointers__[ptr]
	else:
		int key = __tpy_pointers__.size()
		__tpy_pointers__[key] = ptr
		__tpy_rpointers__[ptr] = key
		return key

def tp_get_pointer(int key) -> void*:
	return __tpy_pointers__[ key ]

