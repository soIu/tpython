##TPython Main Header - becomes tp.gen.h

#ifndef TP_H
#define TP_H

define(TINY_LIST_PARAMS=1)

import "half.hpp"

if defined(USE_RPMALLOC):
	import "rpmalloc.h"

if defined(__EMSCRIPTEN_major__):
	import <emscripten.h>
else:
	define(EMSCRIPTEN_KEEPALIVE=)

if defined(USE_EMBEDDED_BYTECODE):
	import "__user_bytecode__.gen.h"

import "blendot/vector2.h"
import "blendot/vector3.h"
import "blendot/quat.h"

if defined(BLENDOT_TYPES):
	import "blendot/color.h"
	import "blendot/rect2.h"
	import "blendot/face3.h"
	import "blendot/plane.h"
	import "blendot/basis.h"
	import "blendot/aabb.h"
	import "blendot/transform.h"
	import "blendot/rid.h"
	import "blendot/scene/3d/spatial.h"
	import "blendot/scene/resources/mesh.h"
	import "blendot/scene/3d/mesh_instance.h"
	import "servers/visual/visual_server_raster.h"

if defined(MINIUNREAL):
	import "miniunreal/MiniUnreal.gen.h"
	import "miniunreal/CoreFwd.h"
	import "miniunreal/EngineFwd.h"
	import "miniunreal/Misc/Char.h"
	import "Internationalization/Text.h"
	import "miniunreal/UObject/Object.h"

if defined(TPY_UNINEXT):
	import "uninext/Core.h"
	import "uninext/Map.h"
	import "uninext/Player.h"
	import "uninext/Minion.h"

import <cstddef>

if defined(INCLUDEOS):
	import <os>
	if defined(INCLUDEOS_VGA):
		import <vga>
		import <hw/ps2.hpp>
	if defined(INCLUDEOS_SVGA):
		import <hw/ps2.hpp>
		import <hw/vga_gfx.hpp>
else:
	if not defined(__MINGW64__):
		import <dlfcn.h>
		static void* __libself__ = NULL


import <functional>
import <algorithm>
##import <map>
import <unordered_map>
import <unordered_set>
import <string>
##import <string_view>  ## missing in older clangs

if not defined(SUPER_TINY):
	import <iostream>
	import <sstream>

import <cstring>
import <vector>
import <sys/stat.h>

if not defined(__USE_ISOC99):
	define(__USE_ISOC99)

##import <stdio.h>
import <stdlib.h>
import <string.h>
import <stdarg.h>
import <math.h>
import <time.h>
import <float.h>

if defined(USE_ODE):
	import "ode_common.hpp"
	import "ode_init.hpp"
	import "ode_objects.hpp"
	import "ode_mass.hpp"
	import "ode_rotation.hpp"
	import "ode_collision_space.hpp"
	import "ode_collision.hpp"
	import "ode_contact.hpp"
	import "ode/common.h"
	import "ode/objects.h"
	import "ode/collision_kernel.h"
	import "ode/collision_std.h"
	import "ode/joints/joint.h"
	import "ode/joints/contact.h"
	import "ode/joints/fixed.h"


## better performance when the compiler is allowed to making the inline decisions
## PGO has no speed up when tp_inline is defined. So here it is defined as nothing.
##define(tp_inline=inline)
define(tp_inline)

## FIXME: increased so that gc doesnt get called while running tp_str()
if defined(INCLUDEOS):
	define(TP_GCMAX=262144)
else:
	if defined(__EMSCRIPTEN_major__):
		##define(TP_GCMAX=16384)
		define(TP_GCMAX=524288)
	else:
		define(TP_GCMAX=524288)
	###########################

##define(TP_REGS=16384)
define(TP_REGS=512)

// fixes bench marking test, might need to be set higher later
//#define TP_GCMAX 65536  // still not enough for heavy loads
//#define TP_GCMAX 2097152  // this is too much with threads

//#define TP_REGS 32768  // not required

define(TP_FRAMES=256)
define(TP_REGS_EXTRA=2)

/* #define TP_REGS_PER_FRAME 256*/

enum TPTypeID:
	TP_NONE = 0,
	TP_NUMBER = 1,
	TP_INTEGER = 2,
	TP_VEC2 = 3,
	TP_VEC3 = 4,
	TP_QUAT = 5,
	TP_COLOR = 6,
	TP_RECT = 7,
	TP_TRI = 8,
	TP_PLANE = 9,
	TP_AABB = 10,
	TP_MAT3 = 11,
	TP_TRANS = 12,
	TP_RID   = 13,
	TP_SPATIAL = 14,
	TP_MESH    = 15,
	TP_MESHI   = 16,
	TP_UNINEXT_GAME = 17,
	TP_UNINEXT_PLAYER = 18,
	TP_UNINEXT_MINION = 19,
	TP_UOBJECT = 20,
	TP_TOBJECT = 21,
	TP_SET   = 25,
	TP_POINTER   = 26,
	TP_LIST_TINY = 27,
	TP_INTERFACE = 28,
	TP_FUNC = 29,
	TP_STRING_ATOMIC=30,
	TP_STRING_TINY=31,
	TP_STRING_4BIT=32,
	## this is not a type, any type >= TP_GC_TRACKED is garbage collected
	TP_GC_TRACKED = 33,
	TP_LIST = 34,
	TP_STRING = 35,
	## this is not a type, any type >= TP_HAS_META can have a metatype
	TP_HAS_META = 40,
	TP_DICT = 41,
	TP_OBJECT = 42,


##struct TPTypeInfo:
##	enum TPTypeID type_id : 32
##	unsigned int magic: 32

struct TPTypeInfo:
	enum TPTypeID type_id : 6
	unsigned int magic :2


##enum TPFuncMagic:
##	TP_FUNC_MASK_C = 1,
##	TP_FUNC_MASK_METHOD = 2,
##	TP_FUNC_MASK_CPP = 100,
##	TP_FUNC_MASK_METHOD_CPP = 101

enum TPFuncMagic:
	TP_FUNC_BYTECODE  = 0,
	TP_FUNC_MAGIC_C   = 1,
	TP_FUNC_MAGIC_CPP = 2,


enum TPStringMagic:
	TP_STRING_NONE = 0,
	TP_STRING_MAGIC_HASH = 1,
	TP_STRING_EXTERN = 2,
	TP_STRING_VIEW = 3

enum TPModuleMagic:
	TP_MODULE_INTERNAL = 0,
	TP_MODULE_EXTERNAL_MAGIC = 1,

enum TPGCMagic:
	TP_GC_MAGIC = 0,
	TP_SKIP_GC_MAGIC = 1,


if defined(TP_BIG_NUM):
	import <quadmath.h>
	##typedef long double tp_num;
	typedef __float128 tp_num;
	typedef __int128 tp_int;
else:
	typedef double tp_num;
	typedef int tp_int;


/* Type: tp_obj
 * Tinypys object representation.
 * 
 * Every object in tinypy is of this type in the C API.
 *
 * Fields:
 * type - This determines what kind of objects it is. It is either TP_NONE, in
 *        which case this is the none type and no other fields can be accessed.
 *        Or it has one of the values listed below, and the corresponding
 *        fields can be accessed.
 * number - TP_NUMBER
 * number.val - A double value with the numeric value.
 * string - TP_STRING
 * string.val - A pointer to the string data.
 * string.len - Length in bytes of the string data.
 * dict - TP_DICT
 * list - TP_LIST
 * func - TP_FUNC
 * data - TP_DATA
 * data.val - The user-provided data pointer.
 * type.magic - The user-provided magic number for identifying the data type.
 */

## https://stackoverflow.com/questions/12094694/c-union-vs-class-inheritance
## https://stackoverflow.com/questions/3615001/why-union-cant-be-used-in-inheritance
## https://stackoverflow.com/questions/34075606/using-inheritance-within-a-union/34076227


struct tp_vm;

// TODO this temp iterator should be thread local, or some other better workaround
class tp_obj;
static std::vector<tp_obj> __temp_iterator__

struct __str4bit__:
	unsigned char a:4
	unsigned char b:4


struct str4bit:
	TPTypeInfo type;
	__str4bit__ chunks[12];
	def encode( char c ) -> char:
		switch c:
			case 'A': return 1
			case 'B': return 2
			case 'C': return 3
			case 'D': return 4
			case '!': return 5
			case '$': return 6
			case '%': return 7
			case '&': return 8
			case '*': return 9
			case '+': return 10
			case '-': return 11
			case '=': return 12
			case '?': return 13
			case '@': return 14
			case '_': return 15
		return 0
	def decode( char c ) -> char:
		switch c:
			case 1: return 'A'
			case 2: return 'B'
			case 3: return 'C'
			case 4: return 'D'
			case 5: return '!'
			case 6: return '$'
			case 7: return '%'
			case 8: return '&'
			case 9: return '*'
			case 10: return '+'
			case 11: return '-'
			case 12: return '='
			case 13: return '?'
			case 14: return '@'
			case 15: return '_'
		return 0
	def set(const char* ptr, int length ):
		int pidx = -1
		for i in range(12):
			pidx ++
			if pidx < length:
				this->chunks[i].a = this->encode( ptr[pidx] )
			else:
				this->chunks[i].a = 0
			pidx ++
			if pidx < length:
				this->chunks[i].b = this->encode( ptr[pidx] )
			else:
				this->chunks[i].b = 0
	def len() ->int:
		int length = 0
		for i in range(12):
			auto chk = this->chunks[i]
			if chk.a == 0:
				break
			else:
				length ++
			if chk.b == 0:
				break
			else:
				length ++
		return length
	def as_string() ->std::string:
		std::string r = ""
		for i in range(12):
			auto chk = this->chunks[i]
			if chk.a == 0:
				break
			else:
				r += this->decode( chk.a )
			if chk.b == 0:
				break
			else:
				r += this->decode( chk.b )
		return r
	def operator[] (int index) ->char:
		return this->as_string()[index]


######## allowed 4bit characters #######
## ABCD!$%&*+-=?@_

@static
def tp_string_is_4bitsable( const char* ptr, int length ) ->bool:
	for i in range(length):
		switch ptr[i]:
			case 'A': break
			case 'B': break
			case 'C': break
			case 'D': break
			case '!': break
			case '$': break
			case '%': break
			case '&': break
			case '*': break
			case '+': break
			case '-': break
			case '=': break
			case '?': break
			case '@': break
			case '_': break
			default: return false
	return true

## a tiny generic 3D object ##

struct TinyObject:
	## 4 bytes
	TPTypeInfo type;
	## 6 bytes
	int8_t  sx:6;
	int16_t rx:10;
	int8_t  sy:6;
	int16_t ry:10;
	int8_t  sz:6;
	int16_t rz:10;
	## 6 bytes
	struct {half_float::half x; half_float::half y; half_float::half z;} pos;


class tp_obj:
	using iterator = std::vector<tp_obj>::iterator;
	using const_iterator = std::vector<tp_obj>::const_iterator;
	iterator begin() { __temp_iterator__=this->as_vector(); return __temp_iterator__.begin(); }
	//const_iterator begin() const { __temp_iterator__=as_vector(); return __temp_iterator__.begin(); }
	iterator end() { return __temp_iterator__.end(); }
	//const_iterator end() const { return __temp_iterator__.end(); }
	tp_obj(){};
	tp_obj(TPTypeID t){ type.type_id=t; };
	tp_obj(int num){ type.type_id=TP_NUMBER; this->number.val=num; };
	@template(typename T)
	def unwrap() -> T*:
		##std::cout << "unwrap::" << this->pointer.val << std::endl;
		return (T*)this->pointer.val
	##@virtual
	##def get() ->tp_obj:
	##	return *this
	union {
	TPTypeInfo type;
	struct { TPTypeInfo type; struct uset_wrapper *val; } uset;
	struct { TPTypeInfo type; uint8_t classid; void* val; } pointer;
	struct { TPTypeInfo type; int * gci; } gc;
	struct { TPTypeInfo type; tp_num val; } number;
	struct { TPTypeInfo type; int val; } integer;
	##struct { TPTypeInfo type; struct tpd_func *info; void *cfnc;} func;
	struct { TPTypeInfo type; struct tpd_func *info; } func;
	## tpd_data is used to store pointers to external C/C++ objects with a custom free function
	## called by the gc, used by module_sdl.h, tpd_data can be deprecated
	##struct { TPTypeInfo type; struct tpd_data *info; void *val; } data;
	struct { TPTypeInfo type; struct tpd_obj *info; } obj;  // what type of object is this?
	if defined(TINY_LIST_PARAMS):
		struct { TPTypeInfo type; struct tpd_tiny_list *val; } lst;
	struct { TPTypeInfo type; struct tpd_list *val; } list;
	struct { TPTypeInfo type; struct tpd_dict *val; } dict;
	struct { TPTypeInfo type; struct tpd_dict *val; } object;
	struct { TPTypeInfo type; struct tpd_dict *val; } interface;
	struct { TPTypeInfo type; struct tpd_string *info; } string;
	struct { TPTypeInfo type; const char * val; } atomstr;
	struct { TPTypeInfo type; char val[12];} str;
	struct str4bit str4;
	struct { TPTypeInfo type; struct Vector2 vec; } __vec2;
	struct { TPTypeInfo type; struct Vector3 vec; } __vec3;
	struct { TPTypeInfo type; struct Quat q; } __quat;
	struct TinyObject __object;
	if defined(BLENDOT_TYPES):
		struct { TPTypeInfo type; struct Color *c; } color;
		struct { TPTypeInfo type; struct Rect2 *r; } rect;
		struct { TPTypeInfo type; struct Face3 *t; } tri;
		struct { TPTypeInfo type; struct Plane *p; } plane;
		struct { TPTypeInfo type; struct AABB *a; } aabb;
		struct { TPTypeInfo type; struct Basis *m; } mat3;
		struct { TPTypeInfo type; struct Transform *t; } trans;
		struct { TPTypeInfo type; struct RID *r; } rid;
		struct { TPTypeInfo type; struct Spatial *ptr; } spatial;
		struct { TPTypeInfo type; struct ArrayMesh *ptr; } mesh;
		struct { TPTypeInfo type; struct MeshInstance *ptr; } meshi;
	if defined(UNREAL_TYPES):
		struct { TPTypeInfo type; struct UObject *ptr; } uob;
	if defined(TPY_UNINEXT):
		//struct { TPTypeInfo type; struct CCore *ptr; } game;
		struct { TPTypeInfo type; struct Player *ptr; } player;
		struct { TPTypeInfo type; struct Minion *ptr; } minion;
	};  // end of union
	tp_obj operator() (std::vector<tp_obj> args);
	tp_obj operator=(int n);
	def operator=(void* ptr) ->tp_obj:
		this->type.type_id = TP_POINTER
		##this->type.magic = TP_POINTER_MAGIC_OPAQUE
		this->pointer.val = ptr
		this->pointer.classid = 0
		return *this
	bool operator==(const char* s) const;
	bool operator==(const tp_obj) const;
	operator std::string() const;
	operator bool() const;
	operator int() const;
	operator float() const;
	##operator const char*() const;   // this was causing problems with the overloaded `print` helper?
	operator char() const;
	operator uint8_t() const;
	tp_obj operator[] (int index);
	tp_obj operator[] (const char*);
	operator long unsigned int() const {return (long unsigned int)this->number.val;};
	@const
	def operator& (int n) ->int:
		return (int)this🠊number.val & n
	@const
	def operator < (int n) ->bool:
		return this🠊number.val < n
	@const
	def operator < (double n) ->bool:
		return this🠊number.val < n
	@const
	def operator > (int n) ->bool:
		return this🠊number.val > n
	@const
	def operator > (tp_obj ob) ->bool:
		return this🠊number.val > ob.number.val
	@const
	def operator >= (int n) ->bool:
		return this🠊number.val >= n
	@const
	def operator >= (long n) ->bool:
		return this🠊number.val >= n
	@const
	def operator!= (const tp_obj & ob) ->bool:
		if this->type.type_id == TP_NONE and ob.type.type_id== TP_NONE:
			return false
		elif this->type.type_id == TP_POINTER and ob.type.type_id== TP_NONE:
			if this->pointer.val==NULL:
				return false
			else:
				return true
		else:
			return true
	@const
	def operator== (int n) ->bool:
		return this🠊number.val == n
	@const
	def operator== (long n) ->bool:
		return this🠊number.val == n
	##def operator+= (int n) ->tp_obj:
	##	this🠊number.val += n
	##	return *this
	def operator+= (double n) ->tp_obj:
		this🠊number.val += n
		return *this
	@const
	def operator+ (const tp_obj & first) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = this🠊number.val + first.number.val
		return val
	@const
	def operator+ (const int n) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = this🠊number.val + n
		return val
	@const
	def operator- (const int n) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = this🠊number.val - n
		return val
	##def operator-= (int n) ->tp_obj:
	##	this🠊number.val -= n
	##	return *this
	def operator-= (double n) ->tp_obj:
		this🠊number.val -= n
		return *this
	@const
	def operator- (const tp_obj & first) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = this🠊number.val - first.number.val
		return val
	@const
	def operator* (const tp_obj & first) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = this🠊number.val * first.number.val
		return val
	@const
	def operator* (double n) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = this🠊number.val * n
		return val
	def operator*= (double n) ->tp_obj:
		this🠊number.val *= n
		return *this
	@const
	def operator/ (const tp_obj & first) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = this🠊number.val / first.number.val
		return val
	@const
	def operator / (int n) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = this🠊number.val / n
		return val
	#ifndef SUPER_TINY
	friend std::ostream & operator << (std::ostream &out, const tp_obj &self);
	#endif
	void append(const char *s);
	void append(std::string s);
	void append(double n);
	void append(int n);
	void append(tp_obj ob);
	std::vector<tp_obj> as_vector();
	def set(const char*, tp_obj) ->tp_obj;
	def set(const char*, const char*) ->tp_obj;
	tp_obj( const char *);
	def reverse() ->tp_obj;
	def contains(int n) ->bool;
	friend bool operator>> (int n, tp_obj self) { return self.contains(n);}
	def as_string() -> std::string;
	def as_cstring() -> const char*;

## base class for all AOT subclasses ##
class tpy_subclass( tp_obj ):
	std::unordered_map<std::string, tp_obj> __methods__

## WASM Object3D ##
class Object3D( tp_obj ):
	def Object3D():
		this🠊type = TPTypeInfo{TP_TOBJECT};
	def Object3D(double x, double y, double z,  double rx, double ry, double rz ):
		this🠊type = TPTypeInfo{TP_TOBJECT};
		this🠊__object.pos.x = x
		this🠊__object.pos.y = y
		this🠊__object.pos.z = z
		this🠊__object.rx = rx
		this🠊__object.ry = ry
		this🠊__object.rz = rz
	def on_update():
		pass
	def x() ->float:
		return this🠊__object.pos.x
	def x( float val ) ->float:
		this🠊__object.pos.x = val
		return val
	def y() ->float:
		return this🠊__object.pos.y
	def y( float val ) ->float:
		this🠊__object.pos.y = val
		return val
	def z() ->float:
		return this🠊__object.pos.z
	def z( float val ) ->float:
		this🠊__object.pos.z = val
		return val
	def rx() ->int:
		return this🠊__object.rx
	def rx( int val ) ->int:
		this🠊__object.rx = val
		return val
	def ry() ->int:
		return this🠊__object.ry
	def ry( int val ) ->int:
		this🠊__object.ry = val
		return val
	def rz() ->int:
		return this🠊__object.rz
	def rz( int val ) ->int:
		this🠊__object.rz = val
		return val


@extern.C
@EMSCRIPTEN_KEEPALIVE 
def Object3D_pos_x( long addr ) ->double;
@extern.C
@EMSCRIPTEN_KEEPALIVE 
def Object3D_pos_y( long addr ) ->double;
@extern.C
@EMSCRIPTEN_KEEPALIVE 
def Object3D_pos_z( long addr ) ->double;
@extern.C
@EMSCRIPTEN_KEEPALIVE 
def Object3D_rot_x( long addr ) ->double;
@extern.C
@EMSCRIPTEN_KEEPALIVE 
def Object3D_rot_y( long addr ) ->double;
@extern.C
@EMSCRIPTEN_KEEPALIVE 
def Object3D_rot_z( long addr ) ->double;



/*
Functions are into several namespaces from lower-level to higher-level:

- `tpd_*` : tinypy data structures;

- `tp_*` : tinypy interpreter C-API;
		   arguments from C arguments;
		   functions may return any C value;
		   return values are usually tracked by gc,
		   unless the name indicates untracked (ending with _nt)
		   add the result to gc before dropping to the Python land.

- `tpy_*` : python language C-API
			arguments from local scope parameter list
			functions always return tp_obj;
			return values are usually tracked by gc if it should,
			unless the name indicates untracked.

*/

struct tpd_obj:
	int gci
	tp_obj meta

struct tpd_string:
	int gci : 1
	int len
	char *s


struct tpd_list:
	uint16_t gci : 1
	uint32_t len : 24
	uint32_t alloc : 24
	tp_obj *items


#ifdef TINY_LIST_PARAMS

define(TINY_LIST_MAX_SIZE=8)

struct tpd_tiny_list:
	int start
	int end
	int index
	tp_obj items[TINY_LIST_MAX_SIZE]
	def clear():
		start = 0
		end = 0
		index = 0
	def push_front(tp_obj ob):
		int i = 10
		while i >= 1:
			items[i] = items[i-1]
			i --
		items[0] = ob
		end ++
		if end >= TINY_LIST_MAX_SIZE:
			raise "tiny list error - max size reached"
	def append(tp_obj ob):
		items[ end ] = ob
		end ++
		if end >= TINY_LIST_MAX_SIZE:
			raise "tiny list error - max size reached"
	def pop_back() ->tp_obj:
		return items[ end-- ]
	def pop_front() ->tp_obj:
		return items[ start++ ]
	def len() ->int:
		return end - start
	def begin():
		index = 0
	def next( tp_obj* ob ) ->bool:
		if index < end:
			*ob = items[index]
			index++
			return true
		return false
#endif

struct tpd_item:
	int used
	int hash
	tp_obj key
	tp_obj val

#ifdef TPY_OPTIMIZE_SIZE

## 40 bytes - but slightly slower than 48 byte version
struct tpd_dict:
	int16_t gci
	tp_obj meta
	tpd_item *items
	int32_t len:24
	int32_t alloc:24
	int16_t used:8

#else

## note: struct order is important here, meta and items must be right after gci, why?
## changing the struct order will cash the old tpd_lua_hash and new XXH32
## 48 bytes
struct tpd_dict:
	int16_t gci
	tp_obj meta
	tpd_item *items
	int len
	int alloc
	int used

#endif


struct tpd_func:
	int gci
	tp_obj code
	tp_obj instance
	##tp_obj globals
	if defined(DEBUG):
		tp_obj name
	void *cfunc
	std::function<tp_obj(tp_vm*)> cppfunc


typedef union tpd_code {
  unsigned char i;
  struct { unsigned char i,a,b,c; } regs;
  struct { char val[4]; } string;
  struct { float val; } number;
} tpd_code;

## a tpython function ##
## the size of this struct makes a huge speed difference,
## just adding name as a default will slow things down.
struct tpd_frame:
	tp_obj code
	tpd_code *cur
	tpd_code *jmp
	tp_obj *regs
	tp_obj *ret_dest
	##tp_obj globals
	int cregs : 16
	if defined(DEBUG):
		tp_obj name
		tp_obj fname
		tp_obj line
		int lineno



/* Type: tp_vm
 * Representation of a tinypy virtual machine instance.
 * 
 * A new tp_vm struct is created with <tp_init>, and will be passed to most
 * tinypy functions as first parameter. It contains all the data associated
 * with an instance of a tinypy virtual machine - so it is easy to have
 * multiple instances running at the same time. When you want to free up all
 * memory used by an instance, call <tp_deinit>.
 * 
 * Fields:
 * These fields are currently documented: 
 * 
 * builtins - A dictionary containing all builtin objects.
 * modules - A dictionary with all loaded modules.
 * params - A list of parameters for the current function call.
 * frames - A list of all call frames.
 * cur - The index of the currently executing call frame.
 * frames[n].globals - A dictionary of global sybmols in callframe n.
 */

struct tp_vm:
	tp_obj builtins
	tp_obj modules
	tp_obj _dict_meta
	tpd_frame frames[TP_FRAMES]
	tp_obj _params
	tp_obj params
	tp_obj _regs
	tp_obj *regs
	tp_obj root
	tp_obj globals
	int jmp
	tp_obj ex
	tp_obj last_result
	char chars[256][2]
	int cur
	void (*echo)(const char* data, int length)
	## gc ##
	tpd_list *white
	tpd_list *grey
	tpd_list *black
	int steps

## this should be thread local
## for now this is just used by the tp_obj functor
static tp_vm *__tpvm_global__ = NULL

define(TP=tp_vm *tp)

##struct tpd_data:
##	int gci
##	void (*free)(TP,tp_obj)

define(tp_True=tp_number(1))
define(tp_False=tp_number(0))
define(True=tp_number(1))
define(False=tp_number(0))

extern tp_obj tp_None;

define(None=tp_None)

if defined(USE_RPMALLOC):
	define( tp_malloc(TP,x) rpcalloc(1,(x)) )
	define( tp_realloc(TP,x,y) rprealloc(x,y) )
	define( tp_free(TP,x) rpfree(x) )
else:
	define( tp_malloc(TP,x) calloc((x),1) )
	define( tp_realloc(TP,x,y) realloc(x,y) )
	define( tp_free(TP,x) free(x) )

#ifdef PURE_AOT
@static
def tp_track(TP, tp_obj o)->tp_obj:
	return o
@static
def tp_grey(TP, tp_obj o):
	pass
#else
def tp_track(TP, tp_obj)->tp_obj;
def tp_grey(TP,tp_obj);
#endif

/* __func__ __VA_ARGS__ __FILE__ __LINE__ */

/* Function: tp_raise
 * Macro to raise an exception.
 * 
 * This macro will return from the current function returning "r". The
 * remaining parameters are used to format the exception message.
 */
##def _tp_raise(TP,tp_obj);
@static
def _tp_raise(TP, tp_obj e):
	std::cout << "tp_vm.cpp _tp_raise (RAISE RUNTIME ERROR)" << std::endl
	#ifndef SUPER_TINY
	std::cout << "  error message: " << e << std::endl
	#endif
	throw "RuntimeError"


#define tp_raise(r, obj) { \
	_tp_raise(tp, obj); \
	return r; \
}

#define tp_raise_printf(r,fmt,...) { \
	_tp_raise(tp, tp_printf(tp, fmt, __VA_ARGS__)); \
	return r; \
}

/* Function: tp_string_from_const
 * Creates a new string object from a C string.
 * 
 * Given a pointer to a C string, creates a tinypy object representing the
 * same string.
 * 
 * *Note* Only a reference to the string will be kept by tinypy, so make sure
 * it does not go out of scope, and dont de-allocate it. Also be aware that
 * tinypy will not delete the string for you. In many cases, it is best to
 * use <tp_string_t> or <tp_string_slice> to create a string where tinypy
 * manages storage for you.
 */

def tp_string_atom(TP, const char * v)->tp_obj;
def tp_string_tiny_atom(const char * v)->tp_obj;

def tp_string_len(tp_obj s) ->int;
def tp_string_tiny_len(tp_obj s)->int;

def tp_string_getptr(tp_obj s) ->char*;

def tp_string_t(TP, int n)->tp_obj;

## Function: tp_cstr
## Fill a C string from a tinypy string, and return as a buffer
## that needs to be freed by tp_free
def tp_cstr(TP, tp_obj v) ->char*;

@static
def tp_string_4bit( const char* ptr, int length ) ->tp_obj:
	tp_obj val = {TP_STRING_4BIT};
	val.str4.set( ptr, length )
	return val

@static
def tp_check_type(TP, int t, tp_obj v) -> tp_obj:
	if v.type.type_id != t:
		tp_raise(
		  tp_None,
		  tp_string_atom(tp, "(tp_check_type) TypeError: unexpected type"))
	return v


## Macros for obtaining objects from the parameter list of the current
## function scope.

#define TP_NO_LIMIT 0

#ifdef TINY_LIST_PARAMS
#define TP_OBJ() (tp->params.lst.val->items[ tp->params.lst.val->index++ ])
#else
#define TP_OBJ() (tp_get(tp, tp->params, tp_None))
#endif

#define TP_TYPE(t) tp_check_type(tp, t, TP_OBJ())
#define TP_NUM() (TP_TYPE(TP_NUMBER).number.val)
#define TP_STR() (TP_TYPE(TP_STRING))
#define TP_DEFAULT(d) (tp->params.list.val->len?tp_get(tp, tp->params, tp_None):(d))

/* Macro: TP_LOOP
 * Macro to iterate over all remaining arguments.
 *
 * If you have a function which takes a variable number of arguments, you can
 * iterate through all remaining arguments for example like this:
 *
 * > tp_obj *my_func(tp_vm *tp)
 * > {
 * >     // We retrieve the first argument like normal.
 * >     tp_obj first = TP_OBJ();
 * >     // Then we iterate over the remaining arguments.
 * >     tp_obj arg;
 * >     TP_LOOP(arg)
 * >         // do something with arg
 * >     TP_END
 * > }
 */
def tpd_list_get(TP, tpd_list *self, int k, const char *error)->tp_obj;

#ifdef TINY_LIST_PARAMS
define TP_LOOP(e):
	while (tp->params.lst.val->next(&e)){

#else

#define TP_LOOP(e) \
int __l = tp->params.list.val->len; \
int __i; for (__i=0; __i<__l; __i++) { \
(e) = tpd_list_get(tp, tp->params.list.val, __i, "TP_LOOP");

#endif

define(TP_END=})

## Function: tp_number
## Creates a new numeric object.

@static
def tp_number(tp_num v) -> tp_obj:
	tp_obj val = {TP_NUMBER};
	val.number.val = v
	return val

@static
def tp_integer(int v) -> tp_obj:
	tp_obj val = {TP_INTEGER};
	val.integer.val = v
	return val

## TPY Sets ##

struct uset_wrapper:
	std::unordered_set<float> numset;
	std::unordered_set<std::string> strset;
	def add( float n ):
		this->numset.insert( n )
	def add( std::string s ):
		this->strset.insert( s )
	def contains( tp_obj k ) -> bool:
		if k.type.type_id == TP_NUMBER:
			if this->numset.count( (float)k.number.val ) > 0:
				return true
			else:
				return false
		elif k.type.type_id == TP_STRING or k.type.type_id == TP_STRING_TINY:
			if this->strset.count( std::string(k) ) > 0:
				return true
			else:
				return false
		else:
			raise "invalid type to check for in set"

@static
def tp_uset( std::unordered_set<float> stdset) ->tp_obj:
	tp_obj s = {TP_SET};
	s.uset.val = new uset_wrapper()
	s.uset.val->numset = stdset
	return s

@static
def tp_uset(tp_obj lst) ->tp_obj:
	##std::cout << "making new set..." << std::endl;
	##std::cout << lst << std::endl;
	tp_obj s = {TP_SET};
	s.uset.val = new uset_wrapper()
	if lst.type.type_id == TP_LIST:
		for item in lst:
			##std::cout << "	" << item << std::endl;
			if item.type.type_id == TP_NUMBER:
				s.uset.val->add( (float)item.number.val )
			elif item.type.type_id == TP_STRING or item.type.type_id == TP_STRING_TINY:
				s.uset.val->add( std::string(item) )
			else:
				raise "invalid value type for set"
	else:
		##std::cout << lst << std::endl;
		raise "invalid type given for set constructor"
	return s

class __is_in__:
	int num;
	tp_obj ob;
	friend __is_in__ operator>> (long n, __is_in__ self) { self.num = n; return self;}
	def operator< (tp_obj o) ->bool:
		this->ob = o
		return true

## TPY POINTERS ##

static std::unordered_map<int, void*> __tpy_pointers__ = {};
static std::unordered_map<void*, int> __tpy_rpointers__ = {};

def tp_set_pointer(void *ptr) -> int;
def tp_get_pointer(int key) -> void*;


##@static
##def tpy_add_pointer(void *ptr) -> tp_obj:
##	int key = tp_set_pointer(ptr)
##	tp_obj num = tp_number( (tp_num)key )
##	return num
@static
def tp_pointer(void *ptr) -> tp_obj:
	tp_obj val = {TP_POINTER};
	val.pointer.val = ptr
	return val

## generic tiny 3D object ##
@static
def tp_tiny_object(double x, double y, double z, double rx, double ry, double rz) -> tp_obj:
	tp_obj val = {TP_TOBJECT};
	val.__object.pos.x = x
	val.__object.pos.y = y
	val.__object.pos.z = z
	val.__object.rx = (int16_t)rx;
	val.__object.ry = (int16_t)ry;
	val.__object.rz = (int16_t)rz;
	return val


## only used by function call params list for now, not GC tracked ##
#ifdef TINY_LIST_PARAMS
@static
def tp_tiny_list(TP) -> tp_obj:
	tp_obj val = {TP_LIST_TINY};
	val.lst.val = (tpd_tiny_list*)tp_malloc(tp, sizeof(tpd_tiny_list))
	val.lst.val->start = 0
	val.lst.val->end = 0
	val.lst.val->index = 0
	return val

@static
def tp_tiny_list() -> tp_obj:
	tp_obj val = {TP_LIST_TINY};
	val.lst.val = (tpd_tiny_list*)tp_malloc(NULL, sizeof(tpd_tiny_list))
	val.lst.val->start = 0
	val.lst.val->end = 0
	val.lst.val->index = 0
	return val

#endif

/*@static
def tp_uninext_engine(CCore *ptr) -> tp_obj:
	tp_obj val = {TP_UNINEXT_GAME};
	//val.game.ptr = ptr
	return val
*/

@static
def tp_vec2(double x, double y) -> tp_obj:
	tp_obj val = {TP_VEC2};
	val.__vec2.vec.x = x
	val.__vec2.vec.y = y
	return val

@static
def vec2(double x, double y) -> tp_obj:
	tp_obj val = {TP_VEC2};
	val.__vec2.vec.x = x
	val.__vec2.vec.y = y
	return val

@static
def tp_vec3(double x, double y, double z) -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.__vec3.vec.x = x
	val.__vec3.vec.y = y
	val.__vec3.vec.z = z
	return val

@static
def vec3(double x, double y, double z) -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.__vec3.vec.x = x
	val.__vec3.vec.y = y
	val.__vec3.vec.z = z
	return val

@static
def vec3() -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.__vec3.vec.x = 0
	val.__vec3.vec.y = 0
	val.__vec3.vec.z = 0
	return val


@static
def tp_vec3(Vector3 v) -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.__vec3.vec = v
	return val

@static
def quat(double x, double y, double z, double w) -> tp_obj:
	tp_obj val = {TP_QUAT};
	##std::cout << "	tp_quat(" << x << ',' << y << ',' << z << ',' << w << std::endl;
	val.__quat.q.x = x
	val.__quat.q.y = y
	val.__quat.q.z = z
	val.__quat.q.w = w
	return val

@static
def tp_quat(double x, double y, double z, double w) -> tp_obj:
	tp_obj val = {TP_QUAT};
	val.__quat.q.x = x
	val.__quat.q.y = y
	val.__quat.q.z = z
	val.__quat.q.w = w
	return val

@static
def vec4(double x, double y, double z, double w) -> tp_obj:
	tp_obj val = {TP_QUAT};
	val.__quat.q.x = x
	val.__quat.q.y = y
	val.__quat.q.z = z
	val.__quat.q.w = w
	return val


#ifdef BLENDOT_TYPES

@static
def tp_color(double r, double g, double b, double a) -> tp_obj:
	tp_obj val = {TP_COLOR};
	val.color.c = new Color()
	val.color.c🠊r = r
	val.color.c🠊g = g
	val.color.c🠊b = b
	val.color.c🠊a = a
	return val

@static
def tp_rect(double x, double y, double w, double h) -> tp_obj:
	tp_obj val = {TP_RECT};
	val.rect.r = new Rect2(x,y,w,h)
	return val

@static
def tp_tri(Vector3 a, Vector3 b, Vector3 c) -> tp_obj:
	tp_obj val = {TP_TRI};
	val.tri.t = new Face3(a,b,c)
	return val

@static
def tp_plane(Vector3 normal, double length) -> tp_obj:
	tp_obj val = {TP_PLANE};
	val.plane.p = new Plane(normal, length)
	return val

@static
def tp_aabb(Vector3 pos, Vector3 size) -> tp_obj:
	tp_obj val = {TP_AABB};
	val.aabb.a = new AABB(pos,size)
	return val


@static
def tp_mat3(Vector3 a, Vector3 b, Vector3 c) -> tp_obj:
	tp_obj val = {TP_MAT3};
	val.mat3.m = new Basis(a,b,c)
	return val

@static
def tp_trans(Basis *b, Vector3 origin) -> tp_obj:
	tp_obj val = {TP_TRANS};
	val.trans.t = new Transform(*b, origin)
	return val

@static
def tp_rid(int id) -> tp_obj:
	tp_obj val = {TP_RID};
	val.rid.r = new RID()
	val.rid.r🠊set_id(id)
	return val

##@static
##def tp_spatial(std::uintptr_t ptr) -> tp_obj:
##	tp_obj val = {TP_SPATIAL};
##	val.spatial.ptr = reinterpret_cast<Spatial*>(ptr)
##	val.spatial.ptr->set_translation(pos)
##	val.spatial.ptr->set_rotation_degrees(rot)
##	val.spatial.ptr->set_scale(scl)
##	return val

@static
def tp_spatial(tp_obj ptr) -> tp_obj:
	tp_obj val = {TP_SPATIAL};
	##val.spatial.ptr = reinterpret_cast<Spatial*>(ptr.pointer.val)
	void* p = tp_get_pointer( (int)ptr.number.val )
	val.spatial.ptr = reinterpret_cast<Spatial*>(p)
	return val

@static
def tp_spatial(Vector3 pos, Vector3 rot, Vector3 scl) -> tp_obj:
	tp_obj val = {TP_SPATIAL};
	val.spatial.ptr = new Spatial()
	val.spatial.ptr->set_translation(pos)
	val.spatial.ptr->set_rotation_degrees(rot)
	val.spatial.ptr->set_scale(scl)
	return val

@static
def tp_mesh() -> tp_obj:
	tp_obj val = {TP_MESH};
	val.mesh.ptr = new ArrayMesh()
	return val

#endif

#ifdef UNREAL_TYPES
@static
def tp_uobject() -> tp_obj:
	tp_obj val = {TP_UOBJECT};
	##val.uob.ptr = new UObject()
	val.uob.ptr = (UObject*)malloc( sizeof(UObject) )
	return val

#endif

/* Function: tp_string_from_const (was tp_string_n)
 * Creates a new string object from a partial C string.
 * 
 * Like <tp_string>, but you specify how many bytes of the given C string to
 * use for the string object. The *note* also applies for this function, as the
 * string reference and length are kept, but no actual substring is stored.
 */

@static
def tp_string_from_const(TP, char const * v, int n)->tp_obj;

def tp_string_from_stdstring(TP, std::string s)->tp_obj;


def tp_params(TP)->tp_obj;
def tp_params_n(TP, int n, tp_obj argv[])->tp_obj;
##def tp_params_v(TP, int n, ...)->tp_obj;
def tp_params_v1(TP, tp_obj a)->tp_obj;
def tp_params_v2(TP, tp_obj a, tp_obj b)->tp_obj;

def tp_import(TP, tp_obj name, tp_obj code, tp_obj fname)->tp_obj;
def tp_import(TP, const char* name, const char* fname)->tp_obj;

def tp_import_from_buffer_with_filename(TP, const char * fname, const char * name, void *codes, int len)->tp_obj;
def tp_import_from_buffer(TP, const char * name, unsigned char *codes, int len)->tp_obj;


##def tp_ez_call(TP, const char *mod, const char *func, tp_obj params)->tp_obj;
##def tp_eval_from_cstr(TP, const char *text, tp_obj globals)->tp_obj;
def tp_exec(TP, tp_obj code)->tp_obj;
def tp_compile(TP, tp_obj text, tp_obj fname)->tp_obj;

##def tp_data_t(TP, int magic, void *v)->tp_obj;
##def tp_data(TP, int magic, void *v)->tp_obj;

def tp_len(TP,tp_obj self)->tp_obj;

def tp_list()->tp_obj;
def tp_list(TP)->tp_obj;
def tp_list_t(TP)->tp_obj;
##define tp_list tp_list_t

def tp_list_nt(TP)->tp_obj;
def tpd_list_append(TP,tpd_list *self, tp_obj v);

def tp_dict_t(TP)->tp_obj;
def tp_dict(TP)->tp_obj;

def tpd_dict_new(TP) ->tpd_dict*;

def tp_object_t(TP)->tp_obj;
#define tp_object tp_object_t
def tp_dict_nt(TP)->tp_obj;

def tp_function(TP, tp_obj v(TP))->tp_obj;

## note: when this is used from user c++, the lamba must capture by `[=]`
## the pointer to self, it is up to the user to delete the pointer later.
def tp_function(TP, std::function<tp_obj(tp_vm*)>) ->tp_obj;
def tp_function(std::function<tp_obj(tp_vm*)>) ->tp_obj;

def tp_method(TP, tp_obj self,tp_obj v(TP)) ->tp_obj;

## note: if below is used for user defined c++ classes,
## the data members of those class instances will be lost on the `self` below,
## because when created on the stack, those members are lost when passed to another function
## TODO capture `self` as a pointer instead for this case.
def tp_method(TP, tp_obj self, std::function<tp_obj(tp_vm*)>) ->tp_obj;

def tp_def(TP, tp_obj code, tp_obj g) ->tp_obj;
def tp_bind(TP, tp_obj function, tp_obj self)->tp_obj;

def tp_printf(TP, const char * fmt, ...)->tp_obj;

def tp_init(int argc, char *argv[]) ->tp_vm*;
def tp_deinit(TP);

def tp_module_sys_init(TP, int argc, char * argv[]);
def tp_module_builtins_init(TP);
def tp_module_compiler_init(TP);
def tp_module_corelib_init(TP);

## Pythonic++ Helper Funcs ##
def len(char s[12]) ->int;
def len(tp_obj ob)->int;
def len(const tp_obj *self) ->int;
def len(const char* s) ->int;
def isstring(tp_obj ob)->bool;
def isstring(TPTypeID id)->bool;

def tp_get_by_char(TP, tp_obj d, char c)->tp_obj;
def tp_set_by_char(TP, tp_obj d, char c, tp_obj v);
def tp_set(TP, tp_obj d, const char* s, tp_obj v) ->tp_obj;
def tp_set(TP, tp_obj d, const char* s, const char* v) ->tp_obj;
def tp_extern_interface(TP) ->tp_obj;
def tp_extern_interface() ->tp_obj;

#ifdef SUPER_TINY
#define print(...)
#else

static std::string cNone   = "\033[00m"
static std::string cRed    ="\033[01;31m"
static std::string cGreen  ="\033[01;32m"
static std::string cBlue   ="\033[01;34m"
static std::string cYellow ="\033[01;33m"
static std::string cPurple ="\033[01;35m"
static std::string cCyan   ="\033[01;36m"
static std::string cWhite  ="\033[01;37m"
static std::string cBold   ="\033[1m"
static std::string cOrange = "\033[00;33m"
static std::string cUnderline="\033[4m"

enum DebugColors:
	DRED
	DGREEN
	DBLUE
	DYELLOW
	DPURPLE
	DCYAN
	DWHITE
	DBOLD
	DORANGE
	DUNDER

@static
def print(DebugColors clr, const char *s):
	#ifdef __EMSCRIPTEN_major__
	  std::cout << s << std::endl;
	#else
	switch clr:
		case DRED:
			std::cout << cRed << s
			break
		case DGREEN:
			std::cout << cGreen << s
			break
		case DBLUE:
			std::cout << cBlue << s
			break
		case DYELLOW:
			std::cout << cYellow << s
			break
		case DPURPLE:
			std::cout << cPurple << s
			break
		case DCYAN:
			std::cout << cCyan << s
			break
		case DWHITE:
			std::cout << cWhite << s
			break
		case DBOLD:
			std::cout << cBold << s
			break
		case DORANGE:
			std::cout << cOrange << s
			break
		case DUNDER:
			std::cout << cUnderline << s
			break
		default:
			std::cout << s
			break
	std::cout << cNone << std::endl;
	#endif

@static
def tp_as_string(TP, tp_obj self, bool quote_strings=true) ->std::string:
	std::stringstream ss
	int type = self.type.type_id
	switch type:
		case TP_STRING_4BIT:
			if quote_strings:
				ss << "``" << self.str4.as_string() << "``";
			else:
				ss << self.str4.as_string()
			break
		case TP_STRING_TINY:
			if quote_strings:
				ss << "`" << std::string(self.str.val, len(self.str.val)) << "`";
			else:
				ss << std::string(self.str.val, len(self.str.val))
			break
		case TP_STRING_ATOMIC:
			if quote_strings:
				ss << "\"" << self.atomstr.val << "\"";
			else:
				ss << self.atomstr.val
			break
		case TP_STRING:
			if self.type.magic == TP_STRING_VIEW:
				#ifdef DEBUG
				  std::cout << "STRING VIEW" << std::endl;
				#endif
				if quote_strings:
					ss << "\"" << std::string(self.string.info🠊s, self.string.info🠊len) << "\""
				else:
					ss << std::string(self.string.info🠊s, self.string.info🠊len)
			else:
				if self.type.magic == TP_STRING_EXTERN:
					//std::cout << "STRING EXTERN" << std::endl;
					if quote_strings:
						ss << "\"" << self.string.info🠊s << "\"";
					else:
						ss << self.string.info🠊s
				else:
					//std::cout << "STRING TYPE" << std::endl;
					if quote_strings:
						ss << "\"" << self.string.info🠊s << "\"";
					else:
						ss << self.string.info🠊s
			break
		case TP_INTEGER: ss << self.integer.val; break;
		case TP_NUMBER:
			if defined(DEBUG):
				ss << "number(" << self.number.val << ") "; 
			else:
				ss << self.number.val; 
			break;
		case TP_FUNC:
			if self.type.magic == TP_FUNC_MAGIC_CPP:
				ss << "function<c++>"
			elif self.type.magic == TP_FUNC_MAGIC_C:
				ss << "function<" << self.func.info🠊cfunc << ">"
			else:
				##ss << "function<" << self.func.info🠊name << ">"
				ss << "function<bytecode>"
			break
		case TP_LIST:
			ss << "["
			for (int i=0; i<self.list.val🠊len; i++):
				ss << tp_as_string(tp, self.list.val->items[i]) << ","
			ss << "]"
			break
		case TP_LIST_TINY:
			ss << "tinylist<"
			if defined(TINY_LIST_PARAMS):
				ss << " start=" << self.lst.val->start << ", end=" << self.lst.val->end << ", index=" << self.lst.val->index
				ss << "["
				for (int i=self.lst.val🠊start; i<self.lst.val🠊end; i++):
					ss << tp_as_string(tp, self.lst.val->items[i]) << ","
				ss << "]"
			ss << ">"
			break
		case TP_DICT:
			ss << "{"
			for (int i=0; i<self.dict.val🠊alloc; i++):
				if self.dict.val🠊items[i].used != 1:
					continue
				##std::cout << self.dict.val->items[i].key << std::endl;
				ss << tp_as_string(tp, self.dict.val🠊items[i].key) << ":"
				## this was only an issue when tp->modules was a dict, now its an interface
				##if isstring(self.dict.val->items[i].key.type.type_id) and (self.dict.val->items[i].key == "__builtins__" or self.dict.val->items[i].key == "modules"):
				##	##throw "cyclic reference"
				##	ss << "{...}"
				##else:
				ss << tp_as_string(tp, self.dict.val🠊items[i].val)
				ss << ","
			ss << "}"
			break
		case TP_OBJECT:
			ss << "object<" << self.object.val << ">{"
			for (int i=0; i<self.dict.val🠊alloc; i++):
				if self.dict.val🠊items[i].used != 1:
					continue
				ss << tp_as_string(tp, self.dict.val🠊items[i].key) << ":"
				if self.dict.val🠊items[i].val.type.type_id==TP_OBJECT:
					ss << "object<" << (void*)self.dict.val🠊items[i].val.object.val << ">"
				else:
					ss << tp_as_string(tp, self.dict.val🠊items[i].val)
				ss << ","
			ss << "}"
			break
		case TP_INTERFACE:
			ss << "interface<" << self.interface.val << ">{"
			for (int i=0; i<self.interface.val🠊alloc; i++):
				if self.interface.val🠊items[i].used != 1:
					continue
				ss << tp_as_string(tp, self.interface.val🠊items[i].key) << "::hash<"
				ss << self.interface.val🠊items[i].hash << ">"
				if self.interface.val🠊items[i].val.type.type_id == TP_FUNC:
					ss << "::" << tp_as_string(tp, self.interface.val🠊items[i].val)
				elif isstring(self.interface.val🠊items[i].val.type.type_id):
					ss << "::" << tp_as_string(tp, self.interface.val🠊items[i].val)
				elif self.interface.val🠊items[i].val.type.type_id==TP_NONE:
					ss << "::None"
				elif self.interface.val🠊items[i].val.type.type_id==TP_NUMBER:
					ss << "::" << self.interface.val🠊items[i].val.number.val
				ss << ", "
			ss << "}"
			break
		case TP_SET:
			ss << "set{"
			for item in self.uset.val->numset:
				ss << item << ","
			for item in self.uset.val->strset:
				ss << item << ","
			ss << "}"
			break
		case TP_POINTER:
			ss << "pointer<" << self.pointer.val << ">"
			break
		case TP_NONE:
			ss << "None"
			break
		case TP_VEC2:
			ss << "vec2( x=" << (double)self.__vec2.vec.x << ", y=" << (double)self.__vec2.vec.y << ")"
			break
		case TP_VEC3:
			ss << "vec3( x=" << (double)self.__vec3.vec.x << ", y=" << (double)self.__vec3.vec.y << ", z=" << (double)self.__vec3.vec.z << ")"
			break
		case TP_QUAT:
			ss << "quat( x=" << self.__quat.q.x << ", y=" << self.__quat.q.y << ", z=" << self.__quat.q.z << ", w=" << self.__quat.q.w << ")"
			break
		case TP_TOBJECT:
			ss << "object3D( position: x=" << self.__object.pos.x << ", y=" << self.__object.pos.y << ", z=" << self.__object.pos.z << " rotation: x=" << self.__object.rx << ", y=" << self.__object.ry << ", z=" << self.__object.rz << ")"
			break
		#ifdef BLENDOT_TYPES
		case TP_COLOR:
			ss << "color( red=" << self.color.c🠊r << ", green=" << self.color.c🠊g << ", blue=" << self.color.c🠊b << ", alpha=" << self.color.c🠊a << ")"
			break
		case TP_RECT:
			ss << "rect( x=" << self.rect.r🠊position.x << ", y=" << self.rect.r🠊position.y << ", width=" << self.rect.r🠊size.x << ", height=" << self.rect.r🠊size.y << ")"
			break
		case TP_TRI:
			ss << "tri(" << std::endl
			ss << "	a:  x=" << self.tri.t🠊vertex[0].x << ", y=" << self.tri.t🠊vertex[0].y << ", z=" << self.tri.t🠊vertex[0].z << std::endl
			ss << "	b:  x=" << self.tri.t🠊vertex[1].x << ", y=" << self.tri.t🠊vertex[1].y << ", z=" << self.tri.t🠊vertex[1].z << std::endl
			ss << "	c:  x=" << self.tri.t🠊vertex[2].x << ", y=" << self.tri.t🠊vertex[2].y << ", z=" << self.tri.t🠊vertex[2].z << std::endl
			ss << ")"
			break
		case TP_PLANE:
			ss << "plane(" << std::endl
			ss << "	normal:  x=" << self.plane.p🠊normal.x << ", y=" << self.plane.p🠊normal.y << ", z=" << self.plane.p🠊normal.z << std::endl
			ss << "	length:  " << self.plane.p🠊d << std::endl
			ss << ")"
			break
		case TP_AABB:
			ss << "aabb(" << std::endl
			ss << "	position:  x=" << self.aabb.a🠊position.x << ", y=" << self.aabb.a🠊position.y << ", z=" << self.aabb.a🠊position.z << std::endl
			ss << "	size:  x=" << self.aabb.a🠊size.x << ", y=" << self.aabb.a🠊size.y << ", z=" << self.aabb.a🠊size.z << std::endl
			ss << ")"
			break
		case TP_MAT3:
			ss << "mat3(" << std::endl
			ss << "	" << self.mat3.m🠊elements[0].x << ", " << self.mat3.m🠊elements[0].y << ", " << self.mat3.m🠊elements[0].z << std::endl
			ss << "	" << self.mat3.m🠊elements[1].x << ", " << self.mat3.m🠊elements[1].y << ", " << self.mat3.m🠊elements[1].z << std::endl
			ss << "	" << self.mat3.m🠊elements[2].x << ", " << self.mat3.m🠊elements[2].y << ", " << self.mat3.m🠊elements[2].z << std::endl
			ss << ")"
			break
		case TP_TRANS:
			ss << "transform(" << std::endl
			ss << "	vec3( x=" << self.trans.t🠊origin.x << ", y=" << self.trans.t🠊origin.y << ", z=" << self.trans.t🠊origin.z << ")"  << std::endl
			ss << "	mat3(" << std::endl
			ss << "		" << self.trans.t🠊basis.elements[0].x << ", " << self.trans.t🠊basis.elements[0].y << ", " << self.trans.t🠊basis.elements[0].z << std::endl
			ss << "		" << self.trans.t🠊basis.elements[1].x << ", " << self.trans.t🠊basis.elements[1].y << ", " << self.trans.t🠊basis.elements[1].z << std::endl
			ss << "		" << self.trans.t🠊basis.elements[2].x << ", " << self.trans.t🠊basis.elements[2].y << ", " << self.trans.t🠊basis.elements[2].z << std::endl
			ss << "	)" << std::endl
			ss << ")"
			break
		case TP_RID:
			ss << "RID( id=" << self.rid.r🠊get_id() << ")"
			break
		case TP_SPATIAL:
			Vector3 pos = self.spatial.ptr🠊get_translation()
			Vector3 rot = self.spatial.ptr🠊get_rotation_degrees()
			Vector3 scl = self.spatial.ptr🠊get_scale()
			ss << "spatial(" << std::endl
			ss << "	addr:		" << self.spatial.ptr << std::endl
			ss << "	position:	x=" << pos.x << ", y=" << pos.y << ", z=" << pos.z << std::endl
			ss << "	rotation:	x=" << rot.x << ", y=" << rot.y << ", z=" << rot.z << std::endl
			ss << "	scale:		x=" << scl.x << ", y=" << scl.y << ", z=" << scl.z << std::endl
			ss << ")"
			break
		case TP_MESH:
			ss << "mesh(" << std::endl
			ss << "	addr:		" << self.mesh.ptr << std::endl
			ss << "	id:		" << self.mesh.ptr->get_rid().get_id() << std::endl
			ss << "	surfaces:	" << self.mesh.ptr->get_surface_count() << std::endl
			ss << ")"
			break
		#endif
		#ifdef UNREAL_TYPES
		case TP_UOBJECT:
			ss << "UObject(" << std::endl
			ss << "	addr:		" << self.uob.ptr << std::endl
			ss << "	sizeof:		" << sizeof(*self.uob.ptr) << std::endl
			ss << ")"
			break
		#endif
		default:
			ss << "<unknown type>"
	return ss.str()

## python-style print helper funcs ##

@static
def print():
	std::cout << std::endl;

@static
def print(const char *s):
	std::cout << s << std::endl;

@static
def print(const char *s, int n):
	std::cout << s << " " << n << std::endl;

@static
def print(const char *s, tp_obj *ob):
	std::cout << s << " " << *ob << std::endl;

@static
def print(const char *s, tp_obj ob):
	std::cout << s << " " << ob << std::endl;

@static
def print(tp_obj ob):
	std::cout << ob << std::endl;

@static
def print(tp_num num):
	std::cout << num << std::endl;

@static
def print(int num):
	std::cout << num << std::endl;

@static
def print(std::string s):
	std::cout << s << std::endl;

@static
def print(void* v):
	std::cout << v << std::endl;

@static
def print(std::vector<int> v):
	std::cout << "[std::vector<int> "
	for i in range(v.size()):
		std::cout << v[i] << ","
	std::cout << "]" << std::endl;

@static
def print(std::vector<std::vector<int>> v):
	std::cout << "[std::vector<std::vector<int>> " << std::endl
	for i in range(v.size()):
		std::cout << "\t"
		print(v[i])
	std::cout << "]" << std::endl;

## end of SUPER_TINY
#endif


#ifndef INCLUDEOS
#ifndef __MINGW64__
@static
def __init_libself__():
	__libself__=dlopen(NULL, 1)
	#ifdef DEBUG
	print(__libself__)
	#endif
#endif
#endif

## Pythonic++ Helper Funcs ##
def chr(int n) ->unsigned char;
def ord(char c) ->int;

@static
def tpyrand() ->double:
	double r = static_cast<double>(std::rand()) / static_cast<double>(RAND_MAX)
	return r

@static
def tpyuniform(double low, double hi) ->double:
	double r = low + static_cast<double>(std::rand()) / (static_cast<double>(RAND_MAX/(hi-low)));
	return r

@static
def __split_string__(std::string text, std::string delims) -> std::vector<std::string>:
	auto tokens = std::vector<std::string>()
	auto len = delims.size()
	std::size_t start = text.find(delims), end = 0
	if start == std::string::npos:
		tokens.push_back(text)
		return tokens
	if start != std::string::npos:
		tokens.push_back(text.substr(0, start))
	while (end = text.find(delims, start+len)) != std::string::npos:
		tokens.push_back(text.substr(start+len, (end-len) - start))
		start = text.find(delims, end)
	if start != std::string::npos:
		tokens.push_back(text.substr(start+len))
	return tokens

@static
def split_tiny_string_as_stdvec(tp_obj txt, std::string delims) -> std::vector<std::string>:
	auto text = std::string((const char*)&txt.str.val, len(txt.str.val))
	auto tokens = std::vector<std::string>()
	auto len = delims.size()
	std::size_t start = text.find(delims), end = 0
	if start == std::string::npos:
		tokens.push_back(text)
		return tokens
	if start != std::string::npos:
		tokens.push_back(text.substr(0, start))
	while (end = text.find(delims, start+len)) != std::string::npos:
		tokens.push_back(text.substr(start+len, (end-len) - start))
		start = text.find(delims, end)
	if start != std::string::npos:
		tokens.push_back(text.substr(start+len))
	return tokens

static std::unordered_map<int, uint32_t>  __tiny_string_hash_cache__ = {};
static tp_obj ATOM_INIT;

import "tp_ops.gen.h"

#ifdef USE_PYTHON
def tpython_compile(std::string src, std::string name) ->std::string;
#endif

#endif
