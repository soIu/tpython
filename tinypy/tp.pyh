##TPython Main Header - becomes tp.gen.h

#ifndef TP_H
#define TP_H

define(TINY_LIST_PARAMS=1)

if defined(USE_RPMALLOC):
	import "rpmalloc.h"

if defined(__EMSCRIPTEN_major__):
	import <emscripten.h>

if defined(USE_EMBEDDED_BYTECODE):
	import "__user_bytecode__.gen.h"

import "blendot/vector2.h"
import "blendot/vector3.h"
import "blendot/quat.h"

if defined(BLENDOT_TYPES):
	import "blendot/color.h"
	import "blendot/rect2.h"
	import "blendot/face3.h"
	import "blendot/plane.h"
	import "blendot/basis.h"
	import "blendot/aabb.h"
	import "blendot/transform.h"
	import "blendot/rid.h"
	import "blendot/scene/3d/spatial.h"
	import "blendot/scene/resources/mesh.h"
	import "blendot/scene/3d/mesh_instance.h"
	import "servers/visual/visual_server_raster.h"

if defined(MINIUNREAL):
	import "miniunreal/MiniUnreal.gen.h"
	import "miniunreal/CoreFwd.h"
	import "miniunreal/EngineFwd.h"
	import "miniunreal/Misc/Char.h"
	import "Internationalization/Text.h"
	import "miniunreal/UObject/Object.h"

import <cstddef>

if defined(INCLUDEOS):
	import <os>
	if defined(INCLUDEOS_VGA):
		import <vga>
		import <hw/ps2.hpp>
	if defined(INCLUDEOS_SVGA):
		import <hw/ps2.hpp>
		import <hw/vga_gfx.hpp>
else:
	if not defined(__MINGW64__):
		import <dlfcn.h>
		static void* __libself__ = NULL


import <functional>
import <algorithm>
import <map>
import <unordered_map>
import <string>
##import <string_view>  ## missing in older clangs
import <iostream>
import <sstream>
import <cstring>
import <vector>
import <sys/stat.h>

if not defined(__USE_ISOC99):
	define(__USE_ISOC99)

import <stdio.h>
import <stdlib.h>
import <string.h>
import <stdarg.h>
import <math.h>
import <time.h>
import <float.h>

if defined(USE_ODE):
	import "ode_common.hpp"
	import "ode_init.hpp"
	import "ode_objects.hpp"
	import "ode_mass.hpp"
	import "ode_rotation.hpp"
	import "ode_collision_space.hpp"
	import "ode_collision.hpp"
	import "ode_contact.hpp"
	import "ode/common.h"
	import "ode/objects.h"
	import "ode/collision_kernel.h"
	import "ode/collision_std.h"
	import "ode/joints/joint.h"
	import "ode/joints/contact.h"


## better performance when the compiler is allowed to making the inline decisions
## PGO has no speed up when tp_inline is defined. So here it is defined as nothing.
##define(tp_inline=inline)
define(tp_inline)

## FIXME: increased so that gc doesnt get called while running tp_str()
if defined(INCLUDEOS):
	//#define TP_GCMAX 16384
	define(TP_GCMAX=262144)
else:
	define(TP_GCMAX=524288)


##define(TP_REGS=16384)
define(TP_REGS=512)

// fixes bench marking test, might need to be set higher later
//#define TP_GCMAX 65536  // still not enough for heavy loads
//#define TP_GCMAX 2097152  // this is too much with threads

//#define TP_REGS 32768  // not required

define(TP_FRAMES=256)
define(TP_REGS_EXTRA=2)

/* #define TP_REGS_PER_FRAME 256*/

enum TPTypeID:
	TP_NONE = 0,
	TP_NUMBER = 1,
	TP_INTEGER = 2,
	TP_VEC2 = 3,
	TP_VEC3 = 4,
	TP_QUAT = 5,
	TP_COLOR = 6,
	TP_RECT = 7,
	TP_TRI = 8,
	TP_PLANE = 9,
	TP_AABB = 10,
	TP_MAT3 = 11,
	TP_TRANS = 12,
	TP_RID   = 13,
	TP_SPATIAL = 14,
	TP_MESH    = 15,
	TP_MESHI   = 16,
	TP_UOBJECT   = 20,
	TP_POINTER   = 26,
	TP_LIST_TINY = 27,
	TP_INTERFACE = 28,
	TP_FUNC = 29,
	TP_STRING_ATOMIC=30,
	TP_STRING_TINY=31
	## this is not a type, any type >= TP_GC_TRACKED is garbage collected
	TP_GC_TRACKED = 32,
	TP_LIST = 34,
	TP_STRING = 35,
	## this is not a type, any type >= TP_HAS_META can have a metatype
	TP_HAS_META = 40,
	TP_DICT = 41,
	TP_OBJECT = 42,


##struct TPTypeInfo:
##	enum TPTypeID type_id : 32
##	unsigned int magic: 32

struct TPTypeInfo:
	enum TPTypeID type_id : 6
	unsigned int magic :2


##enum TPFuncMagic:
##	TP_FUNC_MASK_C = 1,
##	TP_FUNC_MASK_METHOD = 2,
##	TP_FUNC_MASK_CPP = 100,
##	TP_FUNC_MASK_METHOD_CPP = 101

enum TPFuncMagic:
	TP_FUNC_BYTECODE  = 0,
	TP_FUNC_MAGIC_C   = 1,
	TP_FUNC_MAGIC_CPP = 2,


enum TPStringMagic:
	TP_STRING_NONE = 0,
	TP_STRING_MAGIC_HASH = 1,
	TP_STRING_EXTERN = 2,
	TP_STRING_VIEW = 3

enum TPModuleMagic:
	TP_MODULE_INTERNAL = 0,
	TP_MODULE_EXTERNAL_MAGIC = 1,

if defined(TP_BIG_NUM):
	import <quadmath.h>
	##typedef long double tp_num;
	typedef __float128 tp_num;
	typedef __int128 tp_int;
else:
	typedef double tp_num;
	typedef int tp_int;


/* Type: tp_obj
 * Tinypys object representation.
 * 
 * Every object in tinypy is of this type in the C API.
 *
 * Fields:
 * type - This determines what kind of objects it is. It is either TP_NONE, in
 *        which case this is the none type and no other fields can be accessed.
 *        Or it has one of the values listed below, and the corresponding
 *        fields can be accessed.
 * number - TP_NUMBER
 * number.val - A double value with the numeric value.
 * string - TP_STRING
 * string.val - A pointer to the string data.
 * string.len - Length in bytes of the string data.
 * dict - TP_DICT
 * list - TP_LIST
 * func - TP_FUNC
 * data - TP_DATA
 * data.val - The user-provided data pointer.
 * type.magic - The user-provided magic number for identifying the data type.
 */

## https://stackoverflow.com/questions/12094694/c-union-vs-class-inheritance
## https://stackoverflow.com/questions/3615001/why-union-cant-be-used-in-inheritance
## https://stackoverflow.com/questions/34075606/using-inheritance-within-a-union/34076227


struct tp_vm;

class tp_obj:
	tp_obj(){};
	tp_obj(TPTypeID t){ type.type_id=t; };
	tp_obj(int num){ type.type_id=TP_NUMBER; this->number.val=num; };
	@template(typename T)
	def unwrap() -> T*:
		##std::cout << "unwrap::" << this->pointer.val << std::endl;
		return (T*)this->pointer.val
	##@virtual
	##def get() ->tp_obj:
	##	return *this
	union {
	TPTypeInfo type;
	struct { TPTypeInfo type; uint8_t classid; void* val; } pointer;
	struct { TPTypeInfo type; int * gci; } gc;
	struct { TPTypeInfo type; tp_num val; } number;
	struct { TPTypeInfo type; int val; } integer;
	##struct { TPTypeInfo type; struct tpd_func *info; void *cfnc;} func;
	struct { TPTypeInfo type; struct tpd_func *info; } func;
	## tpd_data is used to store pointers to external C/C++ objects with a custom free function
	## called by the gc, used by module_sdl.h, tpd_data can be deprecated
	##struct { TPTypeInfo type; struct tpd_data *info; void *val; } data;
	struct { TPTypeInfo type; struct tpd_obj *info; } obj;  // what type of object is this?
	if defined(TINY_LIST_PARAMS):
		struct { TPTypeInfo type; struct tpd_tiny_list *val; } lst;
	struct { TPTypeInfo type; struct tpd_list *val; } list;
	struct { TPTypeInfo type; struct tpd_dict *val; } dict;
	struct { TPTypeInfo type; struct tpd_dict *val; } object;
	struct { TPTypeInfo type; struct tpd_dict *val; } interface;
	struct { TPTypeInfo type; struct tpd_string *info; } string;
	struct { TPTypeInfo type; const char * val; } atomstr;
	struct { TPTypeInfo type; char val[12];} str;
	struct { TPTypeInfo type; struct Vector2 vec; } vec2;
	struct { TPTypeInfo type; struct Vector3 vec; } __vec3;
	struct { TPTypeInfo type; struct Quat q; } __quat;
	if defined(BLENDOT_TYPES):
		struct { TPTypeInfo type; struct Color *c; } color;
		struct { TPTypeInfo type; struct Rect2 *r; } rect;
		struct { TPTypeInfo type; struct Face3 *t; } tri;
		struct { TPTypeInfo type; struct Plane *p; } plane;
		struct { TPTypeInfo type; struct AABB *a; } aabb;
		struct { TPTypeInfo type; struct Basis *m; } mat3;
		struct { TPTypeInfo type; struct Transform *t; } trans;
		struct { TPTypeInfo type; struct RID *r; } rid;
		struct { TPTypeInfo type; struct Spatial *ptr; } spatial;
		struct { TPTypeInfo type; struct ArrayMesh *ptr; } mesh;
		struct { TPTypeInfo type; struct MeshInstance *ptr; } meshi;
	if defined(UNREAL_TYPES):
		struct { TPTypeInfo type; struct UObject *ptr; } uob;
	};  // end of union
	tp_obj operator=(int n);
	def operator=(void* ptr) ->tp_obj:
		this->type.type_id = TP_POINTER
		##this->type.magic = TP_POINTER_MAGIC_OPAQUE
		this->pointer.val = ptr
		this->pointer.classid = 0
		return *this
	bool operator==(const char* s) const;
	bool operator==(const tp_obj) const;
	operator std::string() const;
	operator bool() const;
	operator int() const;
	operator float() const;
	##operator const char*() const;
	operator char() const;
	operator uint8_t() const;
	tp_obj operator[] (int index);
	operator long unsigned int() const {return (long unsigned int)this->number.val;};
	@const
	def operator& (int n) ->int:
		return (int)thisðŸ Šnumber.val & n
	@const
	def operator < (int n) ->bool:
		return thisðŸ Šnumber.val < n
	@const
	def operator < (double n) ->bool:
		return thisðŸ Šnumber.val < n
	@const
	def operator > (int n) ->bool:
		return thisðŸ Šnumber.val > n
	@const
	def operator > (tp_obj ob) ->bool:
		return thisðŸ Šnumber.val > ob.number.val
	@const
	def operator >= (int n) ->bool:
		return thisðŸ Šnumber.val >= n
	@const
	def operator >= (long n) ->bool:
		return thisðŸ Šnumber.val >= n
	@const
	def operator!= (const tp_obj & ob) ->bool:
		if this->type.type_id == TP_NONE and ob.type.type_id== TP_NONE:
			return false
		elif this->type.type_id == TP_POINTER and ob.type.type_id== TP_NONE:
			if this->pointer.val==NULL:
				return false
			else:
				return true
		else:
			return true
	@const
	def operator== (int n) ->bool:
		return thisðŸ Šnumber.val == n
	@const
	def operator== (long n) ->bool:
		return thisðŸ Šnumber.val == n
	def operator+= (int n) ->tp_obj:
		thisðŸ Šnumber.val += n
		return *this
	@const
	def operator+ (const tp_obj & first) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = thisðŸ Šnumber.val + first.number.val
		return val
	@const
	def operator+ (const int n) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = thisðŸ Šnumber.val + n
		return val
	@const
	def operator- (const int n) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = thisðŸ Šnumber.val - n
		return val
	def operator-= (int n) ->tp_obj:
		thisðŸ Šnumber.val -= n
		return *this
	@const
	def operator- (const tp_obj & first) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = thisðŸ Šnumber.val - first.number.val
		return val
	@const
	def operator* (const tp_obj & first) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = thisðŸ Šnumber.val * first.number.val
		return val
	@const
	def operator/ (const tp_obj & first) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = thisðŸ Šnumber.val / first.number.val
		return val
	@const
	def operator / (int n) ->tp_obj:
		tp_obj val = {TP_NUMBER};
		val.number.val = thisðŸ Šnumber.val / n
		return val
	friend std::ostream & operator << (std::ostream &out, const tp_obj &self);
	void append(const char *s);
	void append(std::string s);
	void append(double n);
	void append(int n);
	void append(tp_obj ob);
	std::vector<tp_obj> as_vector();

## base class for all AOT subclasses ##
class tpy_subclass( tp_obj ):
	std::unordered_map<std::string, tp_obj> __methods__


/*
Functions are into several namespaces from lower-level to higher-level:

- `tpd_*` : tinypy data structures;

- `tp_*` : tinypy interpreter C-API;
		   arguments from C arguments;
		   functions may return any C value;
		   return values are usually tracked by gc,
		   unless the name indicates untracked (ending with _nt)
		   add the result to gc before dropping to the Python land.

- `tpy_*` : python language C-API
			arguments from local scope parameter list
			functions always return tp_obj;
			return values are usually tracked by gc if it should,
			unless the name indicates untracked.

*/

struct tpd_obj:
	int gci
	tp_obj meta

struct tpd_string:
	int gci : 1
	int len
	char *s


struct tpd_list:
	uint16_t gci : 1
	uint32_t len : 24
	uint32_t alloc : 24
	tp_obj *items


#ifdef TINY_LIST_PARAMS

define(TINY_LIST_MAX_SIZE=8)

struct tpd_tiny_list:
	int start
	int end
	int index
	tp_obj items[TINY_LIST_MAX_SIZE]
	def clear():
		start = 0
		end = 0
		index = 0
	def push_front(tp_obj ob):
		int i = 10
		while i >= 1:
			items[i] = items[i-1]
			i --
		items[0] = ob
		end ++
		if end >= TINY_LIST_MAX_SIZE:
			throw "tiny list error - max size reached"
	def append(tp_obj ob):
		items[ end ] = ob
		end ++
		if end >= TINY_LIST_MAX_SIZE:
			throw "tiny list error - max size reached"
	def pop_back() ->tp_obj:
		return items[ end-- ]
	def pop_front() ->tp_obj:
		return items[ start++ ]
	def len() ->int:
		return end - start
	def begin():
		index = 0
	def next( tp_obj* ob ) ->bool:
		if index < end:
			*ob = items[index]
			index++
			return true
		return false
#endif

struct tpd_item:
	int used
	int hash
	tp_obj key
	tp_obj val

#ifdef TPY_OPTIMIZE_SIZE

## 40 bytes - but slightly slower than 48 byte version
struct tpd_dict:
	int16_t gci
	tp_obj meta
	tpd_item *items
	int32_t len:24
	int32_t alloc:24
	int16_t used:8

#else

## note: struct order is important here, meta and items must be right after gci, why?
## changing the struct order will cash the old tpd_lua_hash and new XXH32
## 48 bytes
struct tpd_dict:
	int16_t gci
	tp_obj meta
	tpd_item *items
	int len
	int alloc
	int used

#endif


struct tpd_func:
	int gci
	tp_obj code
	tp_obj instance
	##tp_obj globals
	if defined(DEBUG):
		tp_obj name
	void *cfunc
	std::function<tp_obj(tp_vm*)> cppfunc


typedef union tpd_code {
  unsigned char i;
  struct { unsigned char i,a,b,c; } regs;
  struct { char val[4]; } string;
  struct { float val; } number;
} tpd_code;

## a tpython function ##
## the size of this struct makes a huge speed difference,
## just adding name as a default will slow things down.
struct tpd_frame:
	tp_obj code
	tpd_code *cur
	tpd_code *jmp
	tp_obj *regs
	tp_obj *ret_dest
	##tp_obj globals
	int cregs : 16
	if defined(DEBUG):
		tp_obj name
		tp_obj fname
		tp_obj line
		int lineno



/* Type: tp_vm
 * Representation of a tinypy virtual machine instance.
 * 
 * A new tp_vm struct is created with <tp_init>, and will be passed to most
 * tinypy functions as first parameter. It contains all the data associated
 * with an instance of a tinypy virtual machine - so it is easy to have
 * multiple instances running at the same time. When you want to free up all
 * memory used by an instance, call <tp_deinit>.
 * 
 * Fields:
 * These fields are currently documented: 
 * 
 * builtins - A dictionary containing all builtin objects.
 * modules - A dictionary with all loaded modules.
 * params - A list of parameters for the current function call.
 * frames - A list of all call frames.
 * cur - The index of the currently executing call frame.
 * frames[n].globals - A dictionary of global sybmols in callframe n.
 */

struct tp_vm:
	tp_obj builtins
	tp_obj modules
	tp_obj _dict_meta
	tpd_frame frames[TP_FRAMES]
	tp_obj _params
	tp_obj params
	tp_obj _regs
	tp_obj *regs
	tp_obj root
	tp_obj globals
	int jmp
	tp_obj ex
	tp_obj last_result
	char chars[256][2]
	int cur
	void (*echo)(const char* data, int length)
	## gc ##
	tpd_list *white
	tpd_list *grey
	tpd_list *black
	int steps


define(TP=tp_vm *tp)

##struct tpd_data:
##	int gci
##	void (*free)(TP,tp_obj)

define(tp_True=tp_number(1))
define(tp_False=tp_number(0))
define(True=tp_number(1))
define(False=tp_number(0))

extern tp_obj tp_None;

define(None=tp_None)

if defined(USE_RPMALLOC):
	define( tp_malloc(TP,x) rpcalloc(1,(x)) )
	define( tp_realloc(TP,x,y) rprealloc(x,y) )
	define( tp_free(TP,x) rpfree(x) )
else:
	define( tp_malloc(TP,x) calloc((x),1) )
	define( tp_realloc(TP,x,y) realloc(x,y) )
	define( tp_free(TP,x) free(x) )


def tp_track(TP, tp_obj)->tp_obj;
def tp_grey(TP,tp_obj);

/* __func__ __VA_ARGS__ __FILE__ __LINE__ */

/* Function: tp_raise
 * Macro to raise an exception.
 * 
 * This macro will return from the current function returning "r". The
 * remaining parameters are used to format the exception message.
 */
def _tp_raise(TP,tp_obj);

#define tp_raise(r, obj) { \
	_tp_raise(tp, obj); \
	return r; \
}

#define tp_raise_printf(r,fmt,...) { \
	_tp_raise(tp, tp_printf(tp, fmt, __VA_ARGS__)); \
	return r; \
}

/* Function: tp_string_from_const
 * Creates a new string object from a C string.
 * 
 * Given a pointer to a C string, creates a tinypy object representing the
 * same string.
 * 
 * *Note* Only a reference to the string will be kept by tinypy, so make sure
 * it does not go out of scope, and dont de-allocate it. Also be aware that
 * tinypy will not delete the string for you. In many cases, it is best to
 * use <tp_string_t> or <tp_string_slice> to create a string where tinypy
 * manages storage for you.
 */

def tp_string_atom(TP, const char * v)->tp_obj;
def tp_string_tiny_atom(const char * v)->tp_obj;

def tp_string_len(tp_obj s) ->int;
def tp_string_tiny_len(tp_obj s)->int;

def tp_string_getptr(tp_obj s) ->char*;

def tp_string_t(TP, int n)->tp_obj;

## Function: tp_cstr
## Fill a C string from a tinypy string, and return as a buffer
## that needs to be freed by tp_free
def tp_cstr(TP, tp_obj v) ->char*;


@static
def tp_check_type(TP, int t, tp_obj v) -> tp_obj:
	if v.type.type_id != t:
		tp_raise(
		  tp_None,
		  tp_string_atom(tp, "(tp_check_type) TypeError: unexpected type"))
	return v


## Macros for obtaining objects from the parameter list of the current
## function scope.

#define TP_NO_LIMIT 0

#ifdef TINY_LIST_PARAMS
#define TP_OBJ() (tp->params.lst.val->items[ tp->params.lst.val->index++ ])
#else
#define TP_OBJ() (tp_get(tp, tp->params, tp_None))
#endif

#define TP_TYPE(t) tp_check_type(tp, t, TP_OBJ())
#define TP_NUM() (TP_TYPE(TP_NUMBER).number.val)
#define TP_STR() (TP_TYPE(TP_STRING))
#define TP_DEFAULT(d) (tp->params.list.val->len?tp_get(tp, tp->params, tp_None):(d))

/* Macro: TP_LOOP
 * Macro to iterate over all remaining arguments.
 *
 * If you have a function which takes a variable number of arguments, you can
 * iterate through all remaining arguments for example like this:
 *
 * > tp_obj *my_func(tp_vm *tp)
 * > {
 * >     // We retrieve the first argument like normal.
 * >     tp_obj first = TP_OBJ();
 * >     // Then we iterate over the remaining arguments.
 * >     tp_obj arg;
 * >     TP_LOOP(arg)
 * >         // do something with arg
 * >     TP_END
 * > }
 */
def tpd_list_get(TP, tpd_list *self, int k, const char *error)->tp_obj;

#ifdef TINY_LIST_PARAMS
define TP_LOOP(e):
	while (tp->params.lst.val->next(&e)){

#else

#define TP_LOOP(e) \
int __l = tp->params.list.val->len; \
int __i; for (__i=0; __i<__l; __i++) { \
(e) = tpd_list_get(tp, tp->params.list.val, __i, "TP_LOOP");

#endif

define(TP_END=})

## Function: tp_number
## Creates a new numeric object.

@static
def tp_number(tp_num v) -> tp_obj:
	tp_obj val = {TP_NUMBER};
	val.number.val = v
	return val

@static
def tp_integer(int v) -> tp_obj:
	tp_obj val = {TP_INTEGER};
	val.integer.val = v
	return val

## TPY POINTERS ##

static std::unordered_map<int, void*> __tpy_pointers__ = {};
static std::unordered_map<void*, int> __tpy_rpointers__ = {};

def tp_set_pointer(void *ptr) -> int;
def tp_get_pointer(int key) -> void*;


##@static
##def tpy_add_pointer(void *ptr) -> tp_obj:
##	int key = tp_set_pointer(ptr)
##	tp_obj num = tp_number( (tp_num)key )
##	return num
@static
def tp_pointer(void *ptr) -> tp_obj:
	tp_obj val = {TP_POINTER};
	val.pointer.val = ptr
	return val


## only used by function call params list for now, not GC tracked ##
#ifdef TINY_LIST_PARAMS
@static
def tp_tiny_list(TP) -> tp_obj:
	tp_obj val = {TP_LIST_TINY};
	val.lst.val = (tpd_tiny_list*)tp_malloc(tp, sizeof(tpd_tiny_list))
	val.lst.val->start = 0
	val.lst.val->end = 0
	val.lst.val->index = 0
	return val
#endif


@static
def tp_vec2(double x, double y) -> tp_obj:
	tp_obj val = {TP_VEC2};
	val.vec2.vec.x = x
	val.vec2.vec.y = y
	return val

@static
def tp_vec3(double x, double y, double z) -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.__vec3.vec.x = x
	val.__vec3.vec.y = y
	val.__vec3.vec.z = z
	return val

@static
def vec3(double x, double y, double z) -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.__vec3.vec.x = x
	val.__vec3.vec.y = y
	val.__vec3.vec.z = z
	return val

@static
def vec3() -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.__vec3.vec.x = 0
	val.__vec3.vec.y = 0
	val.__vec3.vec.z = 0
	return val


@static
def tp_vec3(Vector3 v) -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.__vec3.vec = v
	return val

@static
def quat(double x, double y, double z, double w) -> tp_obj:
	tp_obj val = {TP_QUAT};
	##std::cout << "	tp_quat(" << x << ',' << y << ',' << z << ',' << w << std::endl;
	val.__quat.q.x = x
	val.__quat.q.y = y
	val.__quat.q.z = z
	val.__quat.q.w = w
	return val

@static
def tp_quat(double x, double y, double z, double w) -> tp_obj:
	tp_obj val = {TP_QUAT};
	val.__quat.q.x = x
	val.__quat.q.y = y
	val.__quat.q.z = z
	val.__quat.q.w = w
	return val


#ifdef BLENDOT_TYPES

@static
def tp_color(double r, double g, double b, double a) -> tp_obj:
	tp_obj val = {TP_COLOR};
	val.color.c = new Color()
	val.color.cðŸ Šr = r
	val.color.cðŸ Šg = g
	val.color.cðŸ Šb = b
	val.color.cðŸ Ša = a
	return val

@static
def tp_rect(double x, double y, double w, double h) -> tp_obj:
	tp_obj val = {TP_RECT};
	val.rect.r = new Rect2(x,y,w,h)
	return val

@static
def tp_tri(Vector3 a, Vector3 b, Vector3 c) -> tp_obj:
	tp_obj val = {TP_TRI};
	val.tri.t = new Face3(a,b,c)
	return val

@static
def tp_plane(Vector3 normal, double length) -> tp_obj:
	tp_obj val = {TP_PLANE};
	val.plane.p = new Plane(normal, length)
	return val

@static
def tp_aabb(Vector3 pos, Vector3 size) -> tp_obj:
	tp_obj val = {TP_AABB};
	val.aabb.a = new AABB(pos,size)
	return val


@static
def tp_mat3(Vector3 a, Vector3 b, Vector3 c) -> tp_obj:
	tp_obj val = {TP_MAT3};
	val.mat3.m = new Basis(a,b,c)
	return val

@static
def tp_trans(Basis *b, Vector3 origin) -> tp_obj:
	tp_obj val = {TP_TRANS};
	val.trans.t = new Transform(*b, origin)
	return val

@static
def tp_rid(int id) -> tp_obj:
	tp_obj val = {TP_RID};
	val.rid.r = new RID()
	val.rid.rðŸ Šset_id(id)
	return val

##@static
##def tp_spatial(std::uintptr_t ptr) -> tp_obj:
##	tp_obj val = {TP_SPATIAL};
##	val.spatial.ptr = reinterpret_cast<Spatial*>(ptr)
##	val.spatial.ptr->set_translation(pos)
##	val.spatial.ptr->set_rotation_degrees(rot)
##	val.spatial.ptr->set_scale(scl)
##	return val

@static
def tp_spatial(tp_obj ptr) -> tp_obj:
	tp_obj val = {TP_SPATIAL};
	##val.spatial.ptr = reinterpret_cast<Spatial*>(ptr.pointer.val)
	void* p = tp_get_pointer( (int)ptr.number.val )
	val.spatial.ptr = reinterpret_cast<Spatial*>(p)
	return val

@static
def tp_spatial(Vector3 pos, Vector3 rot, Vector3 scl) -> tp_obj:
	tp_obj val = {TP_SPATIAL};
	val.spatial.ptr = new Spatial()
	val.spatial.ptr->set_translation(pos)
	val.spatial.ptr->set_rotation_degrees(rot)
	val.spatial.ptr->set_scale(scl)
	return val

@static
def tp_mesh() -> tp_obj:
	tp_obj val = {TP_MESH};
	val.mesh.ptr = new ArrayMesh()
	return val

#endif

#ifdef UNREAL_TYPES
@static
def tp_uobject() -> tp_obj:
	tp_obj val = {TP_UOBJECT};
	##val.uob.ptr = new UObject()
	val.uob.ptr = (UObject*)malloc( sizeof(UObject) )
	return val

#endif

/* Function: tp_string_from_const (was tp_string_n)
 * Creates a new string object from a partial C string.
 * 
 * Like <tp_string>, but you specify how many bytes of the given C string to
 * use for the string object. The *note* also applies for this function, as the
 * string reference and length are kept, but no actual substring is stored.
 */

@static
def tp_string_from_const(TP, char const * v, int n)->tp_obj;

def tp_string_from_stdstring(TP, std::string s)->tp_obj;


def tp_params(TP)->tp_obj;
def tp_params_n(TP, int n, tp_obj argv[])->tp_obj;
##def tp_params_v(TP, int n, ...)->tp_obj;
def tp_params_v1(TP, tp_obj a)->tp_obj;
def tp_params_v2(TP, tp_obj a, tp_obj b)->tp_obj;

def tp_import(TP, tp_obj name, tp_obj code, tp_obj fname)->tp_obj;
def tp_import(TP, const char* name, const char* fname)->tp_obj;

def tp_import_from_buffer_with_filename(TP, const char * fname, const char * name, void *codes, int len)->tp_obj;
def tp_import_from_buffer(TP, const char * name, unsigned char *codes, int len)->tp_obj;


def tp_ez_call(TP, const char *mod, const char *func, tp_obj params)->tp_obj;
def tp_eval_from_cstr(TP, const char *text, tp_obj globals)->tp_obj;
def tp_exec(TP, tp_obj code)->tp_obj;
def tp_compile(TP, tp_obj text, tp_obj fname)->tp_obj;

def tp_data_t(TP, int magic, void *v)->tp_obj;
def tp_data(TP, int magic, void *v)->tp_obj;

def tp_len(TP,tp_obj self)->tp_obj;

def tp_list()->tp_obj;
def tp_list(TP)->tp_obj;
def tp_list_t(TP)->tp_obj;
##define tp_list tp_list_t

def tp_list_nt(TP)->tp_obj;
def tpd_list_append(TP,tpd_list *self, tp_obj v);

def tp_dict_t(TP)->tp_obj;
def tp_dict(TP)->tp_obj;

def tpd_dict_new(TP) ->tpd_dict*;

def tp_object_t(TP)->tp_obj;
#define tp_object tp_object_t
def tp_dict_nt(TP)->tp_obj;

def tp_function(TP, tp_obj v(TP))->tp_obj;

## note: when this is used from user c++, the lamba must capture by `[=]`
## the pointer to self, it is up to the user to delete the pointer later.
def tp_function(TP, std::function<tp_obj(tp_vm*)>) ->tp_obj;
def tp_function(std::function<tp_obj(tp_vm*)>) ->tp_obj;

def tp_method(TP, tp_obj self,tp_obj v(TP)) ->tp_obj;

## note: if below is used for user defined c++ classes,
## the data members of those class instances will be lost on the `self` below,
## because when created on the stack, those members are lost when passed to another function
## TODO capture `self` as a pointer instead for this case.
def tp_method(TP, tp_obj self, std::function<tp_obj(tp_vm*)>) ->tp_obj;

def tp_def(TP, tp_obj code, tp_obj g) ->tp_obj;
def tp_bind(TP, tp_obj function, tp_obj self)->tp_obj;

def tp_printf(TP, const char * fmt, ...)->tp_obj;

def tp_init(int argc, char *argv[]) ->tp_vm*;
def tp_deinit(TP);

def tp_module_sys_init(TP, int argc, char * argv[]);
def tp_module_builtins_init(TP);
def tp_module_compiler_init(TP);
def tp_module_corelib_init(TP);

## Pythonic++ Helper Funcs ##
def len(char s[12]) ->int;
def len(tp_obj ob)->int;
def len(const tp_obj *self) ->int;
def len(const char* s) ->int;
def isstring(tp_obj ob)->bool;
def isstring(TPTypeID id)->bool;

static std::string cNone   = "\033[00m"
static std::string cRed    ="\033[01;31m"
static std::string cGreen  ="\033[01;32m"
static std::string cBlue   ="\033[01;34m"
static std::string cYellow ="\033[01;33m"
static std::string cPurple ="\033[01;35m"
static std::string cCyan   ="\033[01;36m"
static std::string cWhite  ="\033[01;37m"
static std::string cBold   ="\033[1m"
static std::string cOrange = "\033[00;33m"
static std::string cUnderline="\033[4m"

enum DebugColors:
	DRED
	DGREEN
	DBLUE
	DYELLOW
	DPURPLE
	DCYAN
	DWHITE
	DBOLD
	DORANGE
	DUNDER

@static
def print(DebugColors clr, const char *s):
	switch clr:
		case DRED:
			std::cout << cRed << s
			break
		case DGREEN:
			std::cout << cGreen << s
			break
		case DBLUE:
			std::cout << cBlue << s
			break
		case DYELLOW:
			std::cout << cYellow << s
			break
		case DPURPLE:
			std::cout << cPurple << s
			break
		case DCYAN:
			std::cout << cCyan << s
			break
		case DWHITE:
			std::cout << cWhite << s
			break
		case DBOLD:
			std::cout << cBold << s
			break
		case DORANGE:
			std::cout << cOrange << s
			break
		case DUNDER:
			std::cout << cUnderline << s
			break
		default:
			std::cout << s
			break
	std::cout << cNone << std::endl;


@static
def tp_as_string(TP, tp_obj self, bool quote_strings=true) ->std::string:
	std::stringstream ss
	int type = self.type.type_id
	switch type:
		case TP_STRING_TINY:
			if quote_strings:
				ss << "\"" << std::string(self.str.val, len(self.str.val)) << "\"";
			else:
				ss << std::string(self.str.val, len(self.str.val))
			break
		case TP_STRING_ATOMIC:
			if quote_strings:
				ss << "\"" << self.atomstr.val << "\"";
			else:
				ss << self.atomstr.val
			break
		case TP_STRING:
			if self.type.magic == TP_STRING_VIEW:
				#ifdef DEBUG
				  std::cout << "STRING VIEW" << std::endl;
				#endif
				if quote_strings:
					ss << "\"" << std::string(self.string.infoðŸ Šs, self.string.infoðŸ Šlen) << "\""
				else:
					ss << std::string(self.string.infoðŸ Šs, self.string.infoðŸ Šlen)
			else:
				if self.type.magic == TP_STRING_EXTERN:
					//std::cout << "STRING EXTERN" << std::endl;
					if quote_strings:
						ss << "\"" << self.string.infoðŸ Šs << "\"";
					else:
						ss << self.string.infoðŸ Šs
				else:
					//std::cout << "STRING TYPE" << std::endl;
					if quote_strings:
						ss << "\"" << self.string.infoðŸ Šs << "\"";
					else:
						ss << self.string.infoðŸ Šs
			break
		case TP_INTEGER: ss << self.integer.val; break;
		case TP_NUMBER:
			if defined(DEBUG):
				ss << "number(" << self.number.val << ") "; 
			else:
				ss << self.number.val; 
			break;
		case TP_FUNC:
			if self.type.magic == TP_FUNC_MAGIC_CPP:
				ss << "function<c++>"
			elif self.type.magic == TP_FUNC_MAGIC_C:
				ss << "function<" << self.func.infoðŸ Šcfunc << ">"
			else:
				##ss << "function<" << self.func.infoðŸ Šname << ">"
				ss << "function<bytecode>"
			break
		case TP_LIST:
			ss << "["
			for (int i=0; i<self.list.valðŸ Šlen; i++):
				ss << tp_as_string(tp, self.list.val->items[i]) << ","
			ss << "]"
			break
		case TP_LIST_TINY:
			ss << "tinylist<"
			if defined(TINY_LIST_PARAMS):
				ss << " start=" << self.lst.val->start << ", end=" << self.lst.val->end << ", index=" << self.lst.val->index
				ss << "["
				for (int i=self.lst.valðŸ Šstart; i<self.lst.valðŸ Šend; i++):
					ss << tp_as_string(tp, self.lst.val->items[i]) << ","
				ss << "]"
			ss << ">"
			break
		case TP_DICT:
			ss << "{"
			for (int i=0; i<self.dict.valðŸ Šalloc; i++):
				if self.dict.valðŸ Šitems[i].used != 1:
					continue
				##std::cout << self.dict.val->items[i].key << std::endl;
				ss << tp_as_string(tp, self.dict.valðŸ Šitems[i].key) << ":"
				## this was only an issue when tp->modules was a dict, now its an interface
				##if isstring(self.dict.val->items[i].key.type.type_id) and (self.dict.val->items[i].key == "__builtins__" or self.dict.val->items[i].key == "modules"):
				##	##throw "cyclic reference"
				##	ss << "{...}"
				##else:
				ss << tp_as_string(tp, self.dict.valðŸ Šitems[i].val)
				ss << ","
			ss << "}"
			break
		case TP_OBJECT:
			ss << "object<" << self.object.val << ">{"
			for (int i=0; i<self.dict.valðŸ Šalloc; i++):
				if self.dict.valðŸ Šitems[i].used != 1:
					continue
				ss << tp_as_string(tp, self.dict.valðŸ Šitems[i].key) << ":"
				if self.dict.valðŸ Šitems[i].val.type.type_id==TP_OBJECT:
					ss << "object<" << (void*)self.dict.valðŸ Šitems[i].val.object.val << ">"
				else:
					ss << tp_as_string(tp, self.dict.valðŸ Šitems[i].val)
				ss << ","
			ss << "}"
			break
		case TP_INTERFACE:
			ss << "interface<" << self.interface.val << ">{"
			for (int i=0; i<self.interface.valðŸ Šalloc; i++):
				if self.interface.valðŸ Šitems[i].used != 1:
					continue
				ss << tp_as_string(tp, self.interface.valðŸ Šitems[i].key) << "::hash<"
				ss << self.interface.valðŸ Šitems[i].hash << ">"
				if self.interface.valðŸ Šitems[i].val.type.type_id == TP_FUNC:
					ss << "::" << tp_as_string(tp, self.interface.valðŸ Šitems[i].val)
				elif isstring(self.interface.valðŸ Šitems[i].val.type.type_id):
					ss << "::" << tp_as_string(tp, self.interface.valðŸ Šitems[i].val)
				elif self.interface.valðŸ Šitems[i].val.type.type_id==TP_NONE:
					ss << "::None"
				elif self.interface.valðŸ Šitems[i].val.type.type_id==TP_NUMBER:
					ss << "::" << self.interface.valðŸ Šitems[i].val.number.val
				ss << ", "
			ss << "}"
			break
		case TP_POINTER:
			ss << "pointer<" << self.pointer.val << ">"
			break
		case TP_NONE:
			ss << "None"
			break
		case TP_VEC2:
			ss << "vec2( x=" << self.vec2.vec.x << ", y=" << self.vec2.vec.y << ")"
			break
		case TP_VEC3:
			ss << "vec3( x=" << self.__vec3.vec.x << ", y=" << self.__vec3.vec.y << ", z=" << self.__vec3.vec.z << ")"
			break
		case TP_QUAT:
			ss << "quat( x=" << self.__quat.q.x << ", y=" << self.__quat.q.y << ", z=" << self.__quat.q.z << ", w=" << self.__quat.q.w << ")"
			break
		#ifdef BLENDOT_TYPES
		case TP_COLOR:
			ss << "color( red=" << self.color.cðŸ Šr << ", green=" << self.color.cðŸ Šg << ", blue=" << self.color.cðŸ Šb << ", alpha=" << self.color.cðŸ Ša << ")"
			break
		case TP_RECT:
			ss << "rect( x=" << self.rect.rðŸ Šposition.x << ", y=" << self.rect.rðŸ Šposition.y << ", width=" << self.rect.rðŸ Šsize.x << ", height=" << self.rect.rðŸ Šsize.y << ")"
			break
		case TP_TRI:
			ss << "tri(" << std::endl
			ss << "	a:  x=" << self.tri.tðŸ Švertex[0].x << ", y=" << self.tri.tðŸ Švertex[0].y << ", z=" << self.tri.tðŸ Švertex[0].z << std::endl
			ss << "	b:  x=" << self.tri.tðŸ Švertex[1].x << ", y=" << self.tri.tðŸ Švertex[1].y << ", z=" << self.tri.tðŸ Švertex[1].z << std::endl
			ss << "	c:  x=" << self.tri.tðŸ Švertex[2].x << ", y=" << self.tri.tðŸ Švertex[2].y << ", z=" << self.tri.tðŸ Švertex[2].z << std::endl
			ss << ")"
			break
		case TP_PLANE:
			ss << "plane(" << std::endl
			ss << "	normal:  x=" << self.plane.pðŸ Šnormal.x << ", y=" << self.plane.pðŸ Šnormal.y << ", z=" << self.plane.pðŸ Šnormal.z << std::endl
			ss << "	length:  " << self.plane.pðŸ Šd << std::endl
			ss << ")"
			break
		case TP_AABB:
			ss << "aabb(" << std::endl
			ss << "	position:  x=" << self.aabb.aðŸ Šposition.x << ", y=" << self.aabb.aðŸ Šposition.y << ", z=" << self.aabb.aðŸ Šposition.z << std::endl
			ss << "	size:  x=" << self.aabb.aðŸ Šsize.x << ", y=" << self.aabb.aðŸ Šsize.y << ", z=" << self.aabb.aðŸ Šsize.z << std::endl
			ss << ")"
			break
		case TP_MAT3:
			ss << "mat3(" << std::endl
			ss << "	" << self.mat3.mðŸ Šelements[0].x << ", " << self.mat3.mðŸ Šelements[0].y << ", " << self.mat3.mðŸ Šelements[0].z << std::endl
			ss << "	" << self.mat3.mðŸ Šelements[1].x << ", " << self.mat3.mðŸ Šelements[1].y << ", " << self.mat3.mðŸ Šelements[1].z << std::endl
			ss << "	" << self.mat3.mðŸ Šelements[2].x << ", " << self.mat3.mðŸ Šelements[2].y << ", " << self.mat3.mðŸ Šelements[2].z << std::endl
			ss << ")"
			break
		case TP_TRANS:
			ss << "transform(" << std::endl
			ss << "	vec3( x=" << self.trans.tðŸ Šorigin.x << ", y=" << self.trans.tðŸ Šorigin.y << ", z=" << self.trans.tðŸ Šorigin.z << ")"  << std::endl
			ss << "	mat3(" << std::endl
			ss << "		" << self.trans.tðŸ Šbasis.elements[0].x << ", " << self.trans.tðŸ Šbasis.elements[0].y << ", " << self.trans.tðŸ Šbasis.elements[0].z << std::endl
			ss << "		" << self.trans.tðŸ Šbasis.elements[1].x << ", " << self.trans.tðŸ Šbasis.elements[1].y << ", " << self.trans.tðŸ Šbasis.elements[1].z << std::endl
			ss << "		" << self.trans.tðŸ Šbasis.elements[2].x << ", " << self.trans.tðŸ Šbasis.elements[2].y << ", " << self.trans.tðŸ Šbasis.elements[2].z << std::endl
			ss << "	)" << std::endl
			ss << ")"
			break
		case TP_RID:
			ss << "RID( id=" << self.rid.rðŸ Šget_id() << ")"
			break
		case TP_SPATIAL:
			Vector3 pos = self.spatial.ptrðŸ Šget_translation()
			Vector3 rot = self.spatial.ptrðŸ Šget_rotation_degrees()
			Vector3 scl = self.spatial.ptrðŸ Šget_scale()
			ss << "spatial(" << std::endl
			ss << "	addr:		" << self.spatial.ptr << std::endl
			ss << "	position:	x=" << pos.x << ", y=" << pos.y << ", z=" << pos.z << std::endl
			ss << "	rotation:	x=" << rot.x << ", y=" << rot.y << ", z=" << rot.z << std::endl
			ss << "	scale:		x=" << scl.x << ", y=" << scl.y << ", z=" << scl.z << std::endl
			ss << ")"
			break
		case TP_MESH:
			ss << "mesh(" << std::endl
			ss << "	addr:		" << self.mesh.ptr << std::endl
			ss << "	id:		" << self.mesh.ptr->get_rid().get_id() << std::endl
			ss << "	surfaces:	" << self.mesh.ptr->get_surface_count() << std::endl
			ss << ")"
			break
		#endif
		#ifdef UNREAL_TYPES
		case TP_UOBJECT:
			ss << "UObject(" << std::endl
			ss << "	addr:		" << self.uob.ptr << std::endl
			ss << "	sizeof:		" << sizeof(*self.uob.ptr) << std::endl
			ss << ")"
			break
		#endif
		default:
			ss << "<unknown type>"
	return ss.str()


def tp_get_by_char(TP, tp_obj d, char c)->tp_obj;
def tp_set_by_char(TP, tp_obj d, char c, tp_obj v);
def tp_set(TP, tp_obj d, const char* s, tp_obj v) ->tp_obj;
def tp_set(TP, tp_obj d, const char* s, const char* v) ->tp_obj;
def tp_extern_interface(TP) ->tp_obj;

## python-style print helper funcs ##

@static
def print():
	std::cout << std::endl;

@static
def print(const char *s):
	std::cout << s << std::endl;

@static
def print(const char *s, int n):
	std::cout << s << " " << n << std::endl;

@static
def print(const char *s, tp_obj *ob):
	std::cout << s << " " << *ob << std::endl;

@static
def print(const char *s, tp_obj ob):
	std::cout << s << " " << ob << std::endl;

@static
def print(tp_obj ob):
	std::cout << ob << std::endl;

@static
def print(tp_num num):
	std::cout << num << std::endl;

@static
def print(int num):
	std::cout << num << std::endl;

@static
def print(std::string s):
	std::cout << s << std::endl;

@static
def print(void* v):
	std::cout << v << std::endl;

@static
def print(std::vector<int> v):
	std::cout << "[std::vector<int> "
	for i in range(v.size()):
		std::cout << v[i] << ","
	std::cout << "]" << std::endl;

@static
def print(std::vector<std::vector<int>> v):
	std::cout << "[std::vector<std::vector<int>> " << std::endl
	for i in range(v.size()):
		std::cout << "\t"
		print(v[i])
	std::cout << "]" << std::endl;

#ifndef INCLUDEOS
#ifndef __MINGW64__
@static
def __init_libself__():
	__libself__=dlopen(NULL, 1)
	#ifdef DEBUG
	print(__libself__)
	#endif
#endif
#endif

## Pythonic++ Helper Funcs ##
def chr(int n) ->unsigned char;
def ord(char c) ->int;


@static
def __split_string__(std::string text, std::string delims) -> std::vector<std::string>:
	auto tokens = std::vector<std::string>()
	auto len = delims.size()
	std::size_t start = text.find(delims), end = 0
	if start == std::string::npos:
		tokens.push_back(text)
		return tokens
	if start != std::string::npos:
		tokens.push_back(text.substr(0, start))
	while (end = text.find(delims, start+len)) != std::string::npos:
		tokens.push_back(text.substr(start+len, (end-len) - start))
		start = text.find(delims, end)
	if start != std::string::npos:
		tokens.push_back(text.substr(start+len))
	return tokens

@static
def split_tiny_string_as_stdvec(tp_obj txt, std::string delims) -> std::vector<std::string>:
	auto text = std::string((const char*)&txt.str.val, len(txt.str.val))
	auto tokens = std::vector<std::string>()
	auto len = delims.size()
	std::size_t start = text.find(delims), end = 0
	if start == std::string::npos:
		tokens.push_back(text)
		return tokens
	if start != std::string::npos:
		tokens.push_back(text.substr(0, start))
	while (end = text.find(delims, start+len)) != std::string::npos:
		tokens.push_back(text.substr(start+len, (end-len) - start))
		start = text.find(delims, end)
	if start != std::string::npos:
		tokens.push_back(text.substr(start+len))
	return tokens

static std::unordered_map<int, uint32_t>  __tiny_string_hash_cache__ = {};
static tp_obj ATOM_INIT;

import "tp_ops.gen.h"

#ifdef USE_PYTHON
def tpython_compile(std::string src, std::string name) ->std::string;
#endif

#endif
